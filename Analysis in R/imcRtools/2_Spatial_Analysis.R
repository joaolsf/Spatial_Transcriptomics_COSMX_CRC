

#3- Analysis using imcRtools functions
#The Bodernmiller's pipeline works with both, SPE and SCE, just need to figure out the correct slots of SCE that should be used in the functions.
#Have a look at the help of each function to check which slot of the SCE should be used.

setwd("/Users/joaoluizsfilho/Library/CloudStorage/Dropbox/Work_Files/Matthias_Lab/Projects/COSMX_colon_dataset/COSMX_Colonrectal_cancer_project/TMA_original/imcrtools")


#3.1- Testing some plotting from Bodernmiller's tutorial using the SingleCellExperiment
library(imcRtools)
library(cytomapper)
library(openxlsx)
library(stringr)
library(dittoSeq)
library(RColorBrewer)
library(Rphenograph)
library(igraph)
library(dittoSeq)
library(viridis)
library(bluster)
library(BiocParallel)
library(ggplot2)
library(scran)
library(CATALYST)
library(kohonen)
library(ConsensusClusterPlus)
library(patchwork)
library(pheatmap)
library(gridExtra)
library(SingleCellExperiment)
library(SpatialExperiment)
library(tidyverse)
library(ggridges)
library(scater)
library(cowplot)
library(viridis)

# 1- Read in the spatial experiment object
# 1.1- steinbock generated data
sce <- readRDS("./1_RDS_files/ad_fov01_sce.rds")
sce

spe <- readRDS("./1_RDS_files/adata_fov_integrated_spe.rds")
spe

saveRDS(spe, "./1_RDS_files/adata_fov_integrated_spe.rds")

#By default, single-cell data is read in as SpatialExperiment object. 
#The summarized pixel intensities per channel and cell (here mean intensity) are stored in the counts slot. 
#Columns represent cells and rows represent channels.
counts(spe)[1:5,1:5]

#Metadata associated to individual cells are stored in the colData slot. 
#After initial image processing, these metadata include the numeric identifier (ObjectNumber), 
#the area, and morphological features of each cell. 
#In addition, sample_id stores the image name from which each cell was extracted and the width and height of the corresponding images are stored.
head(colData(sce))

#The main difference between the SpatialExperiment and the SingleCellExperiment data container in the current setting is the way spatial locations of all cells are stored. 
#For the SingleCellExperiment container, the locations are stored in the colData slot 
#while the SpatialExperiment container stores them in the spatialCoords slot:
head(spatialCoords(sce))

#The spatial object graphs generated by steinbock are read into a colPair slot of the SpatialExperiment (or SingleCellExperiment) object. 
#Cell-cell interactions (cells in close spatial proximity) are represented as “edge list” (stored as SelfHits object). 
#Here, the left side represents the column indices of the “from” cells and the right side represents the column indices of the “to” cells.
colPair(sce, "neighborhood")

#Finally, metadata regarding the channels are stored in the rowData slot. 
#This information is extracted from the panel.csv file. 
#Channels are ordered by isotope mass and therefore match the channel order of the multi-channel images
head(rowData(spe))


#2- Single-cell processing
#After reading in the single-cell data, few further processing steps need to be taken.

#2.1- Add aditional metadata
# We can set the colnames of the object to generate unique identifiers per cell:
colnames(spe) <- paste0(spe$ROI, "_", spe$Master_Index)
colnames(spe)

#It is also often the case that sample-specific metadata are available externally. 
#For the current data, we need to link the cancer type (also referred to as “Indication”) to each sample. 
#This metadata is available as external excel file:
#library(openxlsx)
#library(stringr)
#meta <- read.xlsx("steinbock_outputs/sample_metadata.xlsx")
#spe$patient_id <- as.vector(str_extract_all(spe$sample_id, "Patient[1-9]", simplify = TRUE))
#spe$ROI <- as.vector(str_extract_all(spe$sample_id, "00[1-3]", simplify = TRUE))
#spe$indication <- meta$Indication[match(spe$patient_id, meta$Sample.ID)]

unique(spe$Group)
unique(spe$ROI)
unique(spe$CaseID)

#2.2- Transform counts - similar to quantile normalization
#The distribution of expression counts across cells is often observed to be skewed towards the right side meaning lots of cells display low counts and few cells have high counts.
#To avoid analysis biases from these high-expressing cells, the expression counts are commonly transformed or clipped.
#Here, we perform counts transformation using an inverse hyperbolic sine function. This transformation is commonly applied to flow cytometry data. 
#The cofactor here defines the expression range on which no scaling is performed. 
#While the cofactor for CyTOF data is often set to 5, IMC data usually display much lower counts. We therefore apply a cofactor of 1.
#However, other transformations such as log(counts(spe) + 0.01) should be tested when analysing IMC data.

library(dittoSeq)
dittoRidgePlot(spe, var = "CD3", group.by = "CaseID", assay = "counts") +
  ggtitle("CD3 - before transformation")

#the transformation step
assay(spe, "exprs") <- asinh(counts(spe)/1)

dittoRidgePlot(spe, var = "CD3", group.by = "patient_id", assay = "exprs") +
  ggtitle("CD3 - after transformation")

# 2.3- Define interesting channels
#For downstream analysis such as visualization, dimensionality reduction and clustering, only a subset of markers should be used. 
#As convenience, we can store an additional entry in the rowData slot that specifies the markers of interest. 
#Here, we deselect the nuclear markers, which were primarily used for cell segmentation, and keep all other biological targets.

rowData(spe)$use_channel <- !grepl("DNA|Histone", rownames(spe))

# 2.4- Define color schemes
#We will define color schemes for different metadata entries of the data and conveniently store them 
#in the metadata slot of the SpatialExperiment which will be helpful for downstream data visualizations. 
#We will use colors from the RColorBrewer and dittoSeq package but any other coloring package will suffice.

library(RColorBrewer)
color_vectors <- list()

ROI <- setNames(dittoColors(reps = 1)[seq_along(unique(spe$sample_id))], 
                unique(spe$sample_id))
Group <- setNames(brewer.pal(length(unique(spe$Group)), name = "Set2"), 
                  unique(spe$Group))

color_vectors$ROI <- ROI
color_vectors$Group <- Group
color_vectors
metadata(spe)$color_vectors <- color_vectors

unique(spe$cell_type)
unique(spe$hierarchy)

celltype <- setNames(c("#3F1B03", "#F4AD31", "#894F36", "#1C750C", "#EF8ECC", 
                       "#6471E2", "#4DB23B", "#F4800C", "#BF0A3D", "#000"),
                     c("B cells", "CD4 cells", "CD8 cells", "Epithelial", "Endothelium", 
                       "Macrophage", "Neutrophil", "Smooth Muscle Cell", "RBC", "B cell"))

metadata(spe)$color_vectors$celltype <- celltype

majorcelltype <- setNames(c("#3F1B03", "#6471E2", "#4DB23B", "#BF0A3D"),
                          c("Stromal", "Lymphoid", "Myeloid", "Vascular"))
unique(spe$pheno_cluster)

cellcluster <- setNames(c("#00924C","#00EA7B","#D5FFEB","#783D0D",
                              "#BC9201",'#93B220',"#6FB19B", "#D4E8E1",
                              "#AD0791","#FCCDE5","#BBABFF","#7853FF",
                              "#F62ED5","#FEFA35","#E42520","#FB9797",
                              "#FDC77F","#013F89","#01A6C7","#FF7F00",
                              "#5DA5FD","#7AE8FE"
),
c("Tumor epithelial cell", "ChemokinesHigh Tumor epithelial cell", "IGF2+AREG+ Tumor epithelial cell", "Stem cell", 
  "IGF2+AREG+ stem cell", "Goblet cell", "Tuft cell", "ChemokinesHigh tuft cell",
  "Plasma cell", 'B cell', "CD8+ T cell", "CD4+ T cell", "Treg",
  'Fibroblast', 'Pericyte', "Endothelial cell", 'Myofibroblast',
  'SPP1+ macrophage', 'SPP1+ monocyte', 'Neutrophil', 'ChemokinesHigh macrophage',
  'ChemokinesHigh monocyte'))

metadata(sce)$color_vectors$cellcluster <- cellcluster

##################################################################################################################################################################################################################################################################################################################################################################################################################################################################

# 3- Split the SPE object

unique(spe$Group)

# COVID group
spe_COVID <- spe[,spe$Group == "COVID-19"]
saveRDS(spe_COVID, "spe_COVID.rds")

spe_COVID <- readRDS("spe_COVID.rds")

# Pneumonia group
spe_Pneumo <- spe[,spe$Group == "Pneumonia"]
saveRDS(spe_Pneumo, "spe_Pneumo.rds")

spe_Pneumo <- readRDS("spe_Pneumo.rds")

# Non_Pneumonia group
spe_NonPneumo <- spe[,spe$Group == "Non_Pneumonia"]
saveRDS(spe_NonPneumo, "spe_NonPneumo.rds")

spe_NonPneumo <- readRDS("spe_NonPneumo.rds")

unique(spe$HIV)

# HIV pos group
spe_HIVPOS <- spe[,spe$HIV == "HIV_Pos"]
saveRDS(spe_HIVPOS, "spe_HIVPOS.rds")

spe_HIVPOS <- readRDS("spe_HIVPOS.rds")

# HIV neg group
spe_HIVNEG <- spe[,spe$HIV == "HIV_Neg"]
saveRDS(spe_HIVNEG, "spe_HIVNEG.rds")

spe_HIVNEG <- readRDS("spe_HIVNEG.rds")

# 4- Build the Neighborhood graph

sce <- buildSpatialGraph(sce, img_id = "sample_ID", type = "expansion", threshold = 60, coords = c("CenterX_global_px", "CenterY_global_px"))
colPair(spe, "expansion_interaction_graph")

# expansion interaction graph 

plotSpatial(sce, 
            node_color_by = "CIPR_ordered_clusters", 
            img_id = "sample_ID", 
            coords = c("CenterX_global_px", "CenterY_global_px"),
            draw_edges = TRUE, 
            colPairName = "expansion_interaction_graph", 
            node_size_fix = 1,
            nodes_first = FALSE, 
            directed = TRUE,
            edge_color_fix = "black") + 
  scale_color_manual(values = metadata(sce)$color_vectors$cellcluster)

plotSpatial(sce[,sce$sample_ID == "fov10"], 
            node_color_by = "CIPR_ordered_clusters", 
            img_id = "fov", 
            coords = c("CenterX_global_px", "CenterY_global_px"),
            draw_edges = TRUE, 
            colPairName = "expansion_interaction_graph", 
            node_size_fix = 1,
            nodes_first = FALSE, 
            directed = TRUE,
            edge_color_fix = "black") + 
  scale_color_manual(values = metadata(sce)$color_vectors$cellcluster) +
  ggtitle("fov23, Radius graph")

plotSpatial(sce[,sce$sample_ID == "fov14"], 
            node_color_by = "CIPR_ordered_clusters", 
            img_id = "fov", 
            coords = c("CenterX_global_px", "CenterY_global_px"),
            draw_edges = TRUE, 
            colPairName = "expansion_interaction_graph", 
            node_size_fix = 1,
            nodes_first = FALSE, 
            directed = TRUE,
            edge_color_fix = "black") + 
  scale_color_manual(values = metadata(sce)$color_vectors$cellcluster) +
  ggtitle("fov14, Radius graph")

spe_Pneumo <- buildSpatialGraph(spe_Pneumo, img_id = "ROI", type = "expansion", threshold = 20, coords = c("x", "y"))
colPair(spe_Pneumo, "expansion_interaction_graph")

spe_NonPneumo <- buildSpatialGraph(spe_NonPneumo, img_id = "ROI", type = "expansion", threshold = 20, coords = c("x", "y"))
colPair(spe_NonPneumo, "expansion_interaction_graph")

spe_HIVPOS <- buildSpatialGraph(spe_HIVPOS, img_id = "ROI", type = "expansion", threshold = 20, coords = c("x", "y"))
colPair(spe_HIVPOS, "expansion_interaction_graph")

spe_HIVNEG <- buildSpatialGraph(spe_HIVNEG, img_id = "ROI", type = "expansion", threshold = 20, coords = c("x", "y"))
colPair(spe_HIVNEG, "expansion_interaction_graph")

plotSpatial(spe_Pneumo, 
            node_color_by = "pheno_cluster", 
            img_id = "ROI", 
            coords = c("x", "y"),
            draw_edges = TRUE, 
            colPairName = "expansion_interaction_graph", 
            node_size_fix = 0.1,
            nodes_first = FALSE, 
            directed = FALSE,
            edge_color_fix = "grey") + 
  scale_color_manual(values = metadata(spe_Pneumo)$color_vectors$cellcluster) +
  ggtitle("Pneumonia - Radius graph")

plotSpatial(spe_NonPneumo, 
            node_color_by = "pheno_cluster", 
            img_id = "ROI", 
            coords = c("x", "y"),
            draw_edges = TRUE, 
            colPairName = "expansion_interaction_graph", 
            node_size_fix = 0.1,
            nodes_first = FALSE, 
            directed = FALSE,
            edge_color_fix = "grey") + 
  scale_color_manual(values = metadata(spe_NonPneumo)$color_vectors$cellcluster) +
  ggtitle("Non-Pneumonia - Radius graph")

plotSpatial(spe_HIVPOS, 
            node_color_by = "pheno_cluster", 
            img_id = "ROI", 
            coords = c("x", "y"),
            draw_edges = TRUE, 
            colPairName = "expansion_interaction_graph", 
            node_size_fix = 0.1,
            nodes_first = FALSE, 
            directed = FALSE,
            edge_color_fix = "grey") + 
  scale_color_manual(values = metadata(spe_HIVPOS)$color_vectors$cellcluster) +
  ggtitle("HIV POS - Radius graph")


# 5- Spatial Community Analysis - skip this

#The detection of spatial communities was proposed by (Jackson et al. 2020). 
#Here, cells are clustered solely based on their interactions as defined by the spatial object graph. 
#In the following example, we perform spatial community detection separately for epithelial and immune cells.

#The general procedure is as follows:
#1. create a colData(spe) entry that specifies if a cell is part of the tumor or stroma compartment. 
#2. use the detectCommunity function of the imcRtools package to cluster cells within the tumor or stroma compartment solely based on their spatial interaction graph as constructed by the steinbock package.
#Both tumor and stromal spatial communities are stored in the colData of the SpatialExperiment object under the spatial_community identifier.
#We set the seed argument within the SerialParam function for reproducibility purposes. 
#This is important as the global seed is not recognized by functions provided by the BiocParallel package.

spe$Myeloid_Tcell <- ifelse(spe$metaclusters == "Epithelial", "Epithelial", "T cell")

library(BiocParallel)
spe <- detectCommunity(spe, 
                      colPairName = "expansion_interaction_graph", 
                      size_threshold = 10,
                      group_by = "Myeloid_Tcell",
                      BPPARAM = SerialParam(RNGseed = 220819))
#We can now separately visualize the tumor and stromal communities.
#Spatial myeloid communities
plotSpatial(spe[,spe$metaclusters == "Epithelial"], 
            node_color_by = "spatial_community", 
            img_id = "fov", 
            coords = c("CenterX_global_px", "CenterY_global_px"),
            node_size_fix = 0.2) +
  theme(legend.position = "none") +
  ggtitle("Tumor communities") +
  scale_color_manual(values = rev(colors()))

#Spatial Stromal communities
plotSpatial(spe[,spe$metaclusters == "T cell"], 
            node_color_by = "spatial_community", 
            img_id = "fov", 
            coords = c("CenterX_global_px", "CenterY_global_px"),
            node_size_fix = 0.2) +
  theme(legend.position = "none") +
  ggtitle("T-cell communities") +
  scale_color_manual(values = rev(colors()))

#In the next step, the fraction of cell types within each spatial T-cell community is displayed.
library(pheatmap)
library(viridis)

cur_spe <- spe[,spe$metaclusters == "T cell"]

for_plot <- prop.table(table(cur_spe$spatial_community, 
                             cur_spe$CIPR_ordered_clusters), 
                       margin = 1)

pheatmap(for_plot, 
         color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         show_rownames = FALSE, 
         scale = "column")

pheatmap(for_plot, color = viridis(100), show_rownames = FALSE)

#5- Cellular neighborhood analysis

#The following section highlights the use of the imcRtools package to detect cellular neighborhoods. 
#This approach has been proposed by (Goltsev et al. 2018) and (Schürch et al. 2020) to group cells based on information contained in their direct neighborhood.
#(Goltsev et al. 2018) perfomed Delaunay triangulation-based graph construction, neighborhood aggregation and then clustered cells.
#(Schürch et al. 2020) on the other hand constructed a 10-nearest neighbor graph before aggregating information across neighboring cells.
#In the following code chunk we will use the 20-nearest neighbor graph as constructed above to define the direct cellular neighborhood. 
#The aggregateNeighbors function allows neighborhood aggregation in 2 different ways:

#A- For each cell the function computes the fraction of cells of a certain type (e.g., cell type) among its neighbors.
#B- For each cell it aggregates (e.g., mean) the expression counts across all neighboring cells.

#Based on these measures, cells can now be clustered into cellular neighborhoods. 
#We will first compute the fraction of the different cell types among the 20-nearest neighbors and use kmeans clustering to group cells into 6 cellular neighborhoods.

# By celltypes
spe_NonPneumo <- aggregateNeighbors(spe_NonPneumo, colPairName = "expansion_interaction_graph", 
                         aggregate_by = "metadata", count_by = "pheno_cluster")

set.seed(220705)
cn_1 <- kmeans(spe_NonPneumo$aggregatedNeighbors, centers = 4)
cn_2 <- kmeans(spe_NonPneumo$aggregatedNeighbors, centers = 6)

spe_NonPneumo$cn_celltypes <- as.factor(cn_1$cluster)
spe_NonPneumo$cn_celltypes2 <- as.factor(cn_2$cluster)

plotSpatial(spe_Pneumo, 
            node_color_by = "cn_celltypes", 
            img_id = "ROI", 
            coords = c("x", "y"),
            node_size_fix = 0.1) +
  scale_color_brewer(palette = "Set3")

plotSpatial(spe_Pneumo, 
            node_color_by = "cn_celltypes2", 
            img_id = "ROI", 
            coords = c("x", "y"),
            node_size_fix = 0.1) +
  scale_color_brewer(palette = "Set3")

#The next code chunk visualizes the cell type compositions of the detected cellular neighborhoods (CN). k=4
library(tidyverse)
for_plot <- colData(spe_NonPneumo) %>% as_tibble() %>%
  group_by(cn_celltypes, pheno_cluster) %>%
  summarize(count = n()) %>%
  mutate(freq = count / sum(count)) %>%
  pivot_wider(id_cols = cn_celltypes, names_from = pheno_cluster, 
              values_from = freq, values_fill = 0) %>%
  ungroup() %>%
  select(-cn_celltypes)

pheatmap(for_plot, color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         scale = "column")

for_plot2 <- as.data.frame(t(for_plot))
colnames(for_plot2) <- c("CN1", "CN2", "CN3", "CN4")
pheatmap(for_plot2, color = colorRampPalette(c("dark blue", "white", "dark red"))(100), cluster_cols = TRUE,
         scale = "row", angle_col = c("0"))

library(tidyverse)
for_plot <- colData(spe_NonPneumo) %>% as_tibble() %>%
  group_by(cn_celltypes2, pheno_cluster) %>%
  summarize(count = n()) %>%
  mutate(freq = count / sum(count)) %>%
  pivot_wider(id_cols = cn_celltypes2, names_from = pheno_cluster, 
              values_from = freq, values_fill = 0) %>%
  ungroup() %>%
  select(-cn_celltypes2)

pheatmap(for_plot, color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         scale = "column")

for_plot2 <- as.data.frame(t(for_plot))
colnames(for_plot2) <- c("CN1", "CN2", "CN3", "CN4", "CN5", "CN6")
pheatmap(for_plot2, color = colorRampPalette(c("dark blue", "white", "dark red"))(100), cluster_cols = TRUE,
         scale = "row", angle_col = c("0"))


#6- lisaClust
#An alternative to the aggregateNeighbors function is provided by the lisaClust Bioconductor package (Patrick et al. 2021). 
#In contrast to imcRtools, the lisaClust package computes local indicators of spatial associations (LISA) functions and clusters cells based on those. 
#More precise, the package summarizes L-functions from a Poisson point process model to derive numeric vectors 
#for each cell which can then again be clustered using kmeans.

#The lisa function requires a SegmentedCells object which can be generated using the spicyR package.
library(lisaClust)
library(spicyR)

# segmenting spe_COVID
cells <- data.frame(row.names = colnames(spe_COVID))
cells$ObjectNumber <- spe_COVID$Master_Index
cells$ImageNumber <- spe_COVID$ROI
cells$AreaShape_Center_X <- spe_COVID@colData@listData[["X_loc"]]
cells$AreaShape_Center_Y <- spe_COVID@colData@listData[["Y_loc"]]
cells$cellType <- spe_COVID$pheno_cluster
lisa_sc <- SegmentedCells(cells, cellProfiler = TRUE)
lisa_sc

# segmenting spe_Pneumo
cells <- data.frame(row.names = colnames(spe_Pneumo))
cells$ObjectNumber <- spe_Pneumo$Master_Index
cells$ImageNumber <- spe_Pneumo$ROI
cells$AreaShape_Center_X <- spe_Pneumo@colData@listData[["X_loc"]]
cells$AreaShape_Center_Y <- spe_Pneumo@colData@listData[["Y_loc"]]
cells$cellType <- spe_Pneumo$pheno_cluster
lisa_sc <- SegmentedCells(cells, cellProfiler = TRUE)
lisa_sc

# segmenting spe_NonPneumo
cells <- data.frame(row.names = colnames(spe_NonPneumo))
cells$ObjectNumber <- spe_NonPneumo$Master_Index
cells$ImageNumber <- spe_NonPneumo$ROI
cells$AreaShape_Center_X <- spe_NonPneumo@colData@listData[["X_loc"]]
cells$AreaShape_Center_Y <- spe_NonPneumo@colData@listData[["Y_loc"]]
cells$cellType <- spe_NonPneumo$pheno_cluster
lisa_sc <- SegmentedCells(cells, cellProfiler = TRUE)
lisa_sc

#After creating the SegmentedCells object, the lisa function computes LISA curves across a given set of distances. 
#In the following example, we calculate the LISA curves within a 10µm, 20µm and 50µm neighborhood around each cell. 
#Increasing these radii will lead to broader and smoother spatial clusters.
#However, a number of parameter settings should be tested to estimate the robustness of the results.
lisaCurves <- lisa(lisa_sc, Rs = c(10, 20, 50))

# Set NA to 0
lisaCurves[is.na(lisaCurves)] <- 0

lisa_clusters <- kmeans(lisaCurves, centers = 4)$cluster #km=4
lisa_clusters2 <- kmeans(lisaCurves, centers = 6)$cluster #km=6

spe_NonPneumo$lisa_clusters <- as.factor(lisa_clusters)
spe_NonPneumo$lisa_clusters2 <- as.factor(lisa_clusters2)

# Visualisation
plotSpatial(spe_NonPneumo, 
            node_color_by = "lisa_clusters", 
            img_id = "ROI", coords = c("x", "y"),
            node_size_fix = 0.1) +
  scale_color_brewer(palette = "Set3")

plotSpatial(spe_NonPneumo, 
            node_color_by = "lisa_clusters2", 
            img_id = "ROI", coords = c("x", "y"),
            node_size_fix = 0.1) +
  scale_color_brewer(palette = "Set3")

#We can now observe the cell type composition per spatial cluster.
library(tidyverse)
for_plot <- colData(spe_NonPneumo) %>% as_tibble() %>%
  group_by(lisa_clusters, pheno_cluster) %>%
  summarize(count = n()) %>%
  mutate(freq = count / sum(count)) %>%
  pivot_wider(id_cols = lisa_clusters, names_from = pheno_cluster, 
              values_from = freq, values_fill = 0) %>%
  ungroup() %>%
  select(-lisa_clusters)

pheatmap(for_plot, color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         scale = "column")
for_plot2 <- as.data.frame(t(for_plot))
colnames(for_plot2) <- c("CN1", "CN2", "CN3", "CN4")
pheatmap(for_plot2, color = colorRampPalette(c("dark blue", "white", "dark red"))(100), cluster_cols = TRUE,
         scale = "row", angle_col = c("0"))

library(tidyverse)
for_plot <- colData(spe_NonPneumo) %>% as_tibble() %>%
  group_by(lisa_clusters, cell_type) %>%
  summarize(count = n()) %>%
  mutate(freq = count / sum(count)) %>%
  pivot_wider(id_cols = lisa_clusters, names_from = cell_type, 
              values_from = freq, values_fill = 0) %>%
  ungroup() %>%
  select(-lisa_clusters)

pheatmap(for_plot, color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         scale = "column")
for_plot2 <- as.data.frame(t(for_plot))
colnames(for_plot2) <- c("CN1", "CN2", "CN3", "CN4")
pheatmap(for_plot2, color = colorRampPalette(c("dark blue", "white", "dark red"))(100), cluster_cols = TRUE,
         scale = "row", angle_col = c("0"))

library(tidyverse)
for_plot <- colData(spe_NonPneumo) %>% as_tibble() %>%
  group_by(lisa_clusters2, pheno_cluster) %>%
  summarize(count = n()) %>%
  mutate(freq = count / sum(count)) %>%
  pivot_wider(id_cols = lisa_clusters2, names_from = pheno_cluster, 
              values_from = freq, values_fill = 0) %>%
  ungroup() %>%
  select(-lisa_clusters2)

pheatmap(for_plot, color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         scale = "column")
for_plot2 <- as.data.frame(t(for_plot))
colnames(for_plot2) <- c("CN1", "CN2", "CN3", "CN4", "CN5", "CN6")
pheatmap(for_plot2, color = colorRampPalette(c("dark blue", "white", "dark red"))(100), cluster_cols = TRUE,
         scale = "row", angle_col = c("0"))

library(tidyverse)
for_plot <- colData(spe_NonPneumo) %>% as_tibble() %>%
  group_by(lisa_clusters2, cell_type) %>%
  summarize(count = n()) %>%
  mutate(freq = count / sum(count)) %>%
  pivot_wider(id_cols = lisa_clusters2, names_from = cell_type, 
              values_from = freq, values_fill = 0) %>%
  ungroup() %>%
  select(-lisa_clusters2)

pheatmap(for_plot, color = colorRampPalette(c("dark blue", "white", "dark red"))(100), 
         scale = "column")
for_plot2 <- as.data.frame(t(for_plot))
colnames(for_plot2) <- c("CN1", "CN2", "CN3", "CN4", "CN5", "CN6")
pheatmap(for_plot2, color = colorRampPalette(c("dark blue", "white", "dark red"))(100), cluster_cols = TRUE,
         scale = "row", angle_col = c("0"))

#7- Spatial Context Analysis

#Downstream of CN assignments, we will analyze the spatial context (SC) of each cell using three functions from imcRtools.
#While CNs can represent sites of unique local processes, the term SC was coined by Bhate and colleagues (Bhate et al. 2022) 
#and describes tissue regions in which distinct CNs may be interacting. 
#Hence, SCs may be interesting regions of specialized biological events.

#Here, we will first detect SCs using the detectSpatialContext function. 
#This function relies on CN fractions for each cell in a spatial interaction graph (originally a KNN graph),
#which we will calculate using buildSpatialGraph and aggregateNeighbors. 
#We will focus on the CNs derived from cell type fractions but other CN assignments are possible.

#Of note, the window size (k for KNN) for buildSpatialGraph should reflect a length scale 
#on which biological signals can be exchanged and depends, among others, on cell density and tissue area. 
#In view of their divergent functionality, we recommend to use a larger window size for SC (interaction between local processes) than for CN (local processes) detection. 
#Since we used a 20-nearest neighbor graph for CN assignment, we will use a 40-nearest neighbor graph for SC detection. 
#As before, different parameters should be tested.
#Subsequently, the CN fractions are sorted from high-to-low and the SC of each cell is assigned as the minimal combination of SCs that additively surpass a user-defined threshold. 
#The default threshold of 0.9 aims to represent the dominant CNs, hence the most prevalent signals, in a given window.
#For more details and biological validation, please refer to (Bhate et al. 2022).

library(circlize)
library(RColorBrewer)

# Generate k-nearest neighbor graph for SC detection (k=40) 
spe_COVID <- buildSpatialGraph(spe_COVID, img_id = "ROI", 
                        type = "expansion", 
                        name = "expansion_spatialcontext_graph", 
                        threshold = 40, coords = c("x", "y"))

spe_Pneumo <- buildSpatialGraph(spe_Pneumo, img_id = "ROI", 
                               type = "expansion", 
                               name = "expansion_spatialcontext_graph", 
                               threshold = 40, coords = c("x", "y"))

spe_NonPneumo <- buildSpatialGraph(spe_NonPneumo, img_id = "ROI", 
                               type = "expansion", 
                               name = "expansion_spatialcontext_graph", 
                               threshold = 40, coords = c("x", "y"))

# Aggregate based on clustered_neighbors
spe_COVID <- aggregateNeighbors(spe_COVID, 
                         colPairName = "expansion_spatialcontext_graph",
                         aggregate_by = "metadata",
                         count_by = "cn_celltypes", #need to define if use 4 or 6 CNs - I will use 4 for now
                         name = "aggregatedNeighborhood")

spe_Pneumo <- aggregateNeighbors(spe_Pneumo, 
                                colPairName = "expansion_spatialcontext_graph",
                                aggregate_by = "metadata",
                                count_by = "cn_celltypes", #need to define if use 4 or 6 CNs
                                name = "aggregatedNeighborhood")

spe_NonPneumo <- aggregateNeighbors(spe_NonPneumo, 
                                colPairName = "expansion_spatialcontext_graph",
                                aggregate_by = "metadata",
                                count_by = "cn_celltypes", #need to define if use 4 or 6 CNs
                                name = "aggregatedNeighborhood")

# Detect spatial contexts
spe_COVID <- detectSpatialContext(spe_COVID, 
                           entry = "aggregatedNeighborhood",
                           threshold = 0.90,
                           name = "spatial_context")

spe_Pneumo <- detectSpatialContext(spe_Pneumo, 
                                  entry = "aggregatedNeighborhood",
                                  threshold = 0.90,
                                  name = "spatial_context")

spe_NonPneumo <- detectSpatialContext(spe_NonPneumo, 
                                  entry = "aggregatedNeighborhood",
                                  threshold = 0.90,
                                  name = "spatial_context")

# Define SC color scheme
col_SC <- setNames(colorRampPalette(brewer.pal(11, "Spectral"))(length(unique(spe$spatial_context))), 
                   sort(unique(spe$spatial_context)))

# Visualize spatial contexts on images
plotSpatial(spe_COVID, 
            node_color_by = "spatial_context", 
            img_id = "ROI", 
            node_size_fix = 0.05, coords = c("x", "y"),
            colPairName = "expansion_spatialcontext_graph") +
  scale_color_manual(values = col_SC)

plotSpatial(spe_Pneumo, 
            node_color_by = "spatial_context", 
            img_id = "ROI", 
            node_size_fix = 0.05, coords = c("x", "y"),
            colPairName = "expansion_spatialcontext_graph") +
  scale_color_manual(values = col_SC)

plotSpatial(spe_NonPneumo, 
            node_color_by = "spatial_context", 
            img_id = "ROI", 
            node_size_fix = 0.05, coords = c("x", "y"),
            colPairName = "expansion_spatialcontext_graph") +
  scale_color_manual(values = col_SC)

#For ease of interpretation, we will directly compare the CN and SC assignments for a specific ROI.
library(patchwork)

# Compare CN and SC for one patient 
#As expected, we can observe that interfaces between different CNs make up distinct SCs. 
#For instance, interface between CN 3 (TLS region consisting of B and BnT cells) and CN 4 (Plasma- and T-cell dominated) turns to SC 3_4. 
#On the other hand, the core of CN 3 becomes SC 3, since for the neighborhood for these cells is just the cellular neighborhood itself.
p1 <- plotSpatial(spe_COVID[,spe_COVID$ROI == "1507_1_A"], 
                  node_color_by = "cn_celltypes", 
                  img_id = "ROI", 
                  node_size_fix = 1.5, coords = c("x", "y"),
                  colPairName = "expansion_interaction_graph") +
  scale_color_brewer(palette = "Set1")

p2 <- plotSpatial(spe_COVID[,spe_COVID$ROI == "1507_1_A"], 
                  node_color_by = "spatial_context", 
                  img_id = "ROI", 
                  node_size_fix = 1.5, coords = c("x", "y"),
                  colPairName = "expansion_spatialcontext_graph") +
  scale_color_manual(values = col_SC)

p1 + p2

#Next, we filter the SCs based on user-defined thresholds for number of group entries (here at least 3 ROIs) 
#and/or total number of cells (here minimum of 100 cells) per SC with filterSpatialContext.

## Filter spatial contexts
# By number of group entries
adCM2 <- filterSpatialContext(adCM2, 
                           entry = "spatial_context",
                           group_by = "ROI", 
                           group_threshold = 6,
                           cells_threshold = 500)

plotSpatial(adCM2, 
            node_color_by = "spatial_context_filtered", 
            img_id = "ROI", 
            node_size_fix = 0.05, coords = c("X_loc", "Y_loc"),
            colPairName = "expansion_spatialcontext_graph") +
  scale_color_manual(values = col_SC, limits = force)

p1 <- plotSpatial(adCM2[,adCM2$ROI == "PM102-ROI3"], 
                  node_color_by = "cn_celltypes", 
                  img_id = "ROI", 
                  node_size_fix = 0.05, coords = c("X_loc", "Y_loc"),
                  colPairName = "expansion_interaction_graph") +
  scale_color_brewer(palette = "Accent")

p2 <- plotSpatial(adCM2[,adCM2$ROI == "PM102-ROI3"], 
                  node_color_by = "spatial_context_filtered", 
                  img_id = "ROI", 
                  node_size_fix = 0.05, coords = c("X_loc", "Y_loc"),
                  colPairName = "expansion_spatialcontext_graph") +
  scale_color_manual(values = col_SC)

p1 + p2

# By number of group entries and total number of cells
adNonCM <- filterSpatialContext(adNonCM, 
                           entry = "spatial_context",
                           group_by = "ROI", 
                           group_threshold = 6,
                           cells_threshold = 500)

plotSpatial(adNonCM, 
            node_color_by = "spatial_context_filtered", 
            img_id = "ROI", 
            node_size_fix = 0.05, coords = c("X_loc", "Y_loc"),
            colPairName = "expansion_spatialcontext_graph") +
  scale_color_manual(values = col_SC, limits = force)

#Lastly, we can use the plotSpatialContext function to generate SC graphs, 
#analogous to CN combination maps in (Bhate et al. 2022). 
#Returned objects are ggplots, which can be easily modified further. 
#We will create a SC graph for the filtered SCs here.

## Plot spatial context graph 

# Colored by name and size by n_cells
plotSpatialContext(spe_NonPneumo, 
                   entry = "spatial_context",
                   group_by = "ROI",
                   node_color_by = "name",
                   node_size_by = "n_cells",
                   node_label_color_by = "name")


# Colored by n_cells and size by n_group                   
plotSpatialContext(spe_NonPneumo, 
                   entry = "spatial_context",
                   group_by = 'ROI',
                   node_color_by = "n_cells",
                   node_size_by = "n_group",
                   node_label_color_by = "n_cells") +
  scale_color_viridis()


#8-  Patch Detection Analysis

#The previous section focused on detecting cellular neighborhoods in a rather unsupervised fashion. 
#However, the imcRtools package also provides methods for detecting spatial compartments in a supervised fashion. 
#The patchDetection function allows the detection of connected sets of similar cells as proposed by (Hoch et al. 2022). 
#In the following example, we will use the patchDetection function to detect function to detect myeloid, lymphoid and fibroblast patches in three steps:

#A- Find connected sets of cells (using the radius graph).
#B- Components which contain less than 10 cells are excluded.
#C- Expand the components by 1µm to construct a concave hull around the patch and include cells within the patch.

sce <- patchDetection(sce, 
                     patch_cells = sce$CIPR_annotated_clusters == "Tumor epithelial cell",
                     img_id = "sample_ID",
                     expand_by = 60,
                     min_patch_size = 3, #change this
                     coords = c("CenterX_global_px", "CenterY_global_px"),
                     colPairName = "expansion_interaction_graph")

# Define SC color scheme
col_PD <- setNames(colorRampPalette(brewer.pal(11, "Spectral"))(length(unique(sce$patch_id))), 
                   sort(unique(sce$spe$patch_id)))

plotSpatial(sce, 
            node_color_by = "patch_id", 
            img_id = "sample_ID", 
            node_size_fix = 1, coords = c("CenterX_global_px", "CenterY_global_px")) +
  theme(legend.position = "none") + scale_color_manual(values = col_PD)

#We can now measure the size of each patch using the patchSize function and visualize tumor patch distribution per patient.
patch_size <- patchSize(spe_COVID, "patch_id", coords = c("x", "y"))

patch_size <- merge(patch_size, 
                    colData(spe_COVID)[match(patch_size$patch_id, spe_COVID$patch_id),], 
                    by = "patch_id")

ggplot(as.data.frame(patch_size)) + 
  geom_boxplot(aes(ROI, log10(size))) +
  geom_point(aes(ROI, log10(size))) + theme(axis.text.x = element_text(angle=90))
  
  ggplot(as.data.frame(patch_size)) + 
  geom_boxplot(aes(TMAID, log10(size))) +
  geom_point(aes(TMAID, log10(size))) 
  
  ggplot(as.data.frame(patch_size)) + 
    geom_boxplot(aes(Patient, log10(size))) +
    geom_point(aes(Patient, log10(size))) 
  
  ggplot(as.data.frame(patch_size)) + 
  geom_boxplot(aes(Group, log10(size))) +
  geom_point(aes(Group, log10(size))) 


#We can now calculate the fraction of cells within each patch to roughly estimate cell infiltration.
library(tidyverse)
colData(spe_COVID) %>% as_tibble() %>%
  group_by(patch_id, ROI) %>%
  summarize(cell_count = sum(cell_type == "Myeloid"),
            patch_size = n(),
            cell_freq = cell_count / patch_size) %>%
  ggplot() +
  geom_point(aes(log10(patch_size), cell_freq, color = ROI)) +
  theme_classic()

library(tidyverse)
colData(adNonCM) %>% as_tibble() %>%
  group_by(patch_id, Patient) %>%
  summarize(Tcell_count = sum(cell_type == "CD8 T cells" | cell_type == "CD4 T cells"),
            patch_size = n(),
            Tcell_freq = Tcell_count / patch_size) %>%
  ggplot() +
  geom_point(aes(log10(patch_size), Tcell_freq, color = Patient)) +
  theme_classic()

#We can now calculate the fraction of B cells within each lymphoid patch to roughly estimate B cell infiltration.
colData(adCM2) %>% as_tibble() %>%
  group_by(patch_id, Patient) %>%
  summarize(Bcell_count = sum(cell_type == "B cells"),
            patch_size = n(),
            Bcell_freq = Bcell_count / patch_size) %>%
  ggplot() +
  geom_point(aes(log10(patch_size), Bcell_freq, color = Patient)) +
  theme_classic()

colData(adNonCM) %>% as_tibble() %>%
  group_by(patch_id, Patient) %>%
  summarize(Bcell_count = sum(cell_type == "B cells"),
            patch_size = n(),
            Bcell_freq = Bcell_count / patch_size) %>%
  ggplot() +
  geom_point(aes(log10(patch_size), Bcell_freq, color = Patient)) +
  theme_classic()

#We can now calculate the fraction of Macrophages within each patch to roughly estimate infiltration.
colData(ad) %>% as_tibble() %>%
  group_by(patch_id, Patient) %>%
  summarize(DC_count = sum(cell_type == "Dendritic cells"),
            patch_size = n(),
            DC_freq = DC_count / patch_size) %>%
  ggplot() +
  geom_point(aes(log10(patch_size), DC_freq, color = Patient)) +
  theme_classic()


#The minDistToCells function can be used to calculate the minimum distance between each cell and a cell set of interest. 
#Here, we highlight its use to calculate the minimum distance of all cells to the detected tumor patches. 
#Negative values indicate the minimum distance of each tumor patch cell to a non-tumor patch cell.
spe <- minDistToCells(spe, 
                      x_cells = !is.na(spe$patch_id), 
                      img_id = "sample_id")

plotSpatial(spe, 
            node_color_by = "distToCells", 
            img_id = "sample_id", 
            node_size_fix = 0.5) +
  scale_color_gradient2(low = "dark blue", mid = "white", high = "dark red")

#Finally, we can observe the minimum distances to tumor patches in a cell type specific manner.
library(ggridges)
ggplot(as.data.frame(colData(spe))) + 
  geom_density_ridges(aes(distToCells, celltype, fill = celltype)) +
  geom_vline(xintercept = 0, color = "dark red", size = 2) +
  scale_fill_manual(values = metadata(spe)$color_vectors$celltype)

#9- Interaction analysis

#The next section focuses on statistically testing the pairwise interaction between all cell types of the dataset. 
#For this, the imcRtools package provides the testInteractions function which implements the interaction testing strategy proposed by (Schapiro et al. 2017).
#Per grouping level (e.g., image), the testInteractions function computes the averaged cell type/cell type interaction count 
#and computes this count against an empirical null distribution which is generated by permuting all cell labels (while maintaining the tissue structure).
#In the following example, we use the steinbock generated spatial interaction graph and estimate the interaction or avoidance between cell types in the dataset.

library(scales)
out <- testInteractions(spe_COVID, 
                        group_by = "ROI",
                        label = "pheno_cluster", 
                        colPairName = "expansion_interaction_graph",
                        BPPARAM = SerialParam(RNGseed = 221029))

out2 <- testInteractions(spe_Pneumo, 
                        group_by = "ROI",
                        label = "pheno_cluster", 
                        colPairName = "expansion_interaction_graph",
                        BPPARAM = SerialParam(RNGseed = 221029))

out3 <- testInteractions(spe_NonPneumo, 
                         group_by = "ROI",
                         label = "pheno_cluster", 
                         colPairName = "expansion_interaction_graph",
                         BPPARAM = SerialParam(RNGseed = 221029))

#The returned DataFrame contains the test results per grouping level (in this case the ROI, group_by),
#“from” cell type (from_label) and “to” cell type (to_label). 
#The sigval entry indicates if a pair of cell types is significantly interacting (sigval = 1),
#if a pair of cell types is significantly avoiding (sigval = -1) or if no significant interaction or avoidance was detected.
#These results can be visualized by computing the sum or the mean of the sigval entries across all images:
out %>% as_tibble() %>%
  group_by(from_label, to_label) %>%
  summarize(mean_sigval = mean(sigval, na.rm = TRUE)) %>%
  ggplot() +
  geom_tile(aes(from_label, to_label, fill = mean_sigval)) +
  scale_fill_gradient2(low = muted("blue"), mid = "white", high = muted("red")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

out2 %>% as_tibble() %>%
  group_by(from_label, to_label) %>%
  summarize(mean_sigval = mean(sigval, na.rm = TRUE)) %>%
  ggplot() +
  geom_tile(aes(from_label, to_label, fill = mean_sigval)) +
  scale_fill_gradient2(low = muted("blue"), mid = "white", high = muted("red")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

out3 %>% as_tibble() %>%
  group_by(from_label, to_label) %>%
  summarize(mean_sigval = mean(sigval, na.rm = TRUE)) %>%
  ggplot() +
  geom_tile(aes(from_label, to_label, fill = mean_sigval)) +
  scale_fill_gradient2(low = muted("blue"), mid = "white", high = muted("red")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

#The imcRtools package further implements an interaction testing strategy proposed by (Schulz et al. 2018) 
#where the hypothesis is tested if at least n cells of a certain type are located around a target cell type (from_cell). 
#This type of testing can be performed by selecting method = "patch" and specifying the number of patch cells via the patch_size parameter.

out4 <- testInteractions(spe_COVID, 
                        group_by = "ROI",
                        label = "pheno_cluster", 
                        colPairName = "expansion_interaction_graph",
                        method = "patch", 
                        patch_size = 3,
                        BPPARAM = SerialParam(RNGseed = 221029))

out5 <- testInteractions(spe_Pneumo, 
                         group_by = "ROI",
                         label = "pheno_cluster", 
                         colPairName = "expansion_interaction_graph",
                         method = "patch", 
                         patch_size = 3,
                         BPPARAM = SerialParam(RNGseed = 221029))

out6 <- testInteractions(spe_NonPneumo, 
                         group_by = "ROI",
                         label = "pheno_cluster", 
                         colPairName = "expansion_interaction_graph",
                         method = "patch", 
                         patch_size = 3,
                         BPPARAM = SerialParam(RNGseed = 221029))

out4 %>% as_tibble() %>%
  group_by(from_label, to_label) %>%
  summarize(mean_sigval = mean(sigval, na.rm = TRUE)) %>%
  ggplot() +
  geom_tile(aes(from_label, to_label, fill = mean_sigval)) +
  scale_fill_gradient2(low = muted("blue"), mid = "white", high = muted("red")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

out5 %>% as_tibble() %>%
  group_by(from_label, to_label) %>%
  summarize(mean_sigval = mean(sigval, na.rm = TRUE)) %>%
  ggplot() +
  geom_tile(aes(from_label, to_label, fill = mean_sigval)) +
  scale_fill_gradient2(low = muted("blue"), mid = "white", high = muted("red")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

out6 %>% as_tibble() %>%
  group_by(from_label, to_label) %>%
  summarize(mean_sigval = mean(sigval, na.rm = TRUE)) %>%
  ggplot() +
  geom_tile(aes(from_label, to_label, fill = mean_sigval)) +
  scale_fill_gradient2(low = muted("blue"), mid = "white", high = muted("red")) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

#These results are comparable to the interaction testing presented above. 
#The main difference comes from the lack of symmetry. We can now for example see that 3 or more myeloid cells sit around CD4 T cells 
#while this interaction is not as strong when considering CD4 T cells sitting around myeloid cells.

#Finally, we save the updated SpatialExperiment object.
saveRDS(spe, "spe.rds")


























