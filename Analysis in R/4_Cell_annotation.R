
setwd("/Users/joaoluizsfilho/Library/CloudStorage/Dropbox/Work_Files/Matthias_Lab/Projects/COSMX_colon_dataset/COSMX_Colonrectal_cancer_project/TMA_original/Seurat")

library(dplyr)
library(patchwork)
library(tidyverse)
library(cowplot)
library(viridis)
library(ggplot2)
library(dittoSeq)
library(Seurat)
library(Azimuth)
library(SeuratDisk)
library(SeuratData)
library(viridis)
library(RColorBrewer)
library(DoubletFinder)
library(DropletUtils)
library(dsb)
library(harmony)
library(EnhancedVolcano)
library(basilisk)
library(zellkonverter)
library(reticulate)
library(Matrix)
library(org.Hs.eg.db)
library(gridExtra)
library(SingleCellExperiment)
library(SpatialExperiment)
library(tidyverse)
library(ggridges)
library(garnett)
library(monocle3)

options(ggrepel.max.overlaps = Inf)

fov_integrated <- readRDS("./RDS_files/5_Integration/All/fov_integrated.rds")
saveRDS(fov_integrated, "./fov_integrated.rds")

sce <- readRDS("./RDS_files/5_Integration/All/fov_integrated_sce.rds")
saveRDS(sce, "fov_integrated_sce.rds")


# 14- Cluster annotation with marker gene databases

# 14.1- Cell Annotation with scCATCH

# Reference: https://github.com/ZJUFanLab/scCATCH
# Reference: https://raw.githack.com/ZJUFanLab/scCATCH_performance_comparison/master/scCATCH/tutorial.html
# This package is a single cell Cluster-based auto-Annotation Toolkit for Cellular Heterogeneity (scCATCH) from cluster potential marker genes identification to cluster annotation based on evidence-based score 
# by matching the potential marker genes with known cell markers in tissue-specific cell taxonomy reference database (CellMatch).
library(scCATCH)

set.seed(1234)
DefaultAssay(fov_integrated) <- "RNA"
Idents(fov_integrated) <- 'harmony_clusters'
levels(fov_integrated)

# Create scCATCH object from Seurat object:
obj <- createscCATCH(data = fov_integrated[['RNA']]@data, cluster = as.character(Idents(fov_integrated)))
saveRDS(obj, "fov_integrated_scCATCH_object.rds")

# 14.1.1- Find marker gene for each cluster
# Users need to provided the speices, tissue, or cancer information. 
# Use similar parmaters to those used with the FindAllMarkers function from Seurat
# Available tissues and cancers at https://github.com/ZJUFanLab/scCATCH/wiki
# Select different combination of tissues or cancers for annotation
cellmatch$tissue
# filter cellmatch
cellmatch <- cellmatch[cellmatch$species == "Human", ]
cellmatch <- cellmatch[cellmatch$tissue %in% c("Blood", "Peripheral blood", "Serum", "Colon", "Colorectum", "Intestine"), ]
cellmatch <- cellmatch[cellmatch$cancer %in% c("Colon Cancer", "Colorectal Cancer"), ]

obj <- findmarkergene(obj, species = 'Human', cluster = "All", if_use_custom_marker = FALSE, marker = cellmatch, 
                      tissue = c("Blood", "Colon", "Colorectum", "Intestine"),
                      cancer = c("Colorectal Cancer"),
                      use_method = "2", cell_min_pct = 0.1,logfc = 0.25, pvalue = 0.05, verbose = TRUE)

# 14.1.2- Find cell type for each cluster
obj <- findcelltype(obj)

# 14.2- Cell Annotation with SCSA

# Reference: https://github.com/bioinfo-ibms-pumc/SCSA
# To annotate a human scRNA-seq sets generated by 'FindAllMarkers' function of Seurat with ensemblIDs, use the following code:
# -d DB, --db DB        Database for annotation. (whole.db)
# -s SOURCE, --source Source of marker genes. (cellranger,[seurat],[scanpy], [scran])
# -i INPUT, --input INPUT Input file for marker annotation(Only CSV format supported).
# -k TISSUE, --tissue Tissue for annotation. Only used for cellmarker database. Multiple tissues should be seperated by commas.Run '-l' option to see all tissues.
# In linux platform:('All',['Bone marrow'],['Bone marrow,Brain,Blood'][...])
# python3 SCSA.py -d whole_v2.db -s seurat -i Markers_harmony_clusters.csv -k All -E -g Human -p 0.05 -f 1.5

# Add SCSA cluster lables
Idents(fov_integrated) <- "harmony_clusters"
levels(fov_integrated)
SCSA_clusters_st1 <- c("Epithelial cell", "Macrophage", "Epithelial cell", "T cell", "Fibroblast", "Epithelial cell", "Endothelial cell", "B cell", "Epithelial cell", "Fibroblast", "Epithelial cell",
                       "Plasma cell", "Epithelial cell", "Monocyte", "T cell", "Fibroblast","B cell", "Plasma cell", "Plasma cell", "T cell", "Epithelial cell", "Smooth muscle cell",
                       "Epithelial cell", "Monocyte", "Plasma cell") # st1 means clusters from strategy 1
names(SCSA_clusters_st1) <- levels(fov_integrated)
fov_integrated <- RenameIdents(fov_integrated, SCSA_clusters_st1)

# Adding object metadata with
fov_integrated$SCSA_clusters_st1 <- factor(fov_integrated@active.ident)

metaclusters <- c("Epithelial", "Myeloid", "Epithelial", "T cell", "Stromal", "Epithelial", "Stromal", "B cell", "Epithelial", "Stromal", "Epithelial",
                       "B cell", "Epithelial", "Myeloid", "T cell", "Stromal","B cell", "B cell", "B cell", "T cell", "Epithelial", "Stromal",
                       "Epithelial", "Myeloid", "B cell") # st1 means clusters from strategy 1
names(metaclusters) <- levels(fov_integrated)
fov_integrated <- RenameIdents(fov_integrated, metaclusters)

# Adding object metadata with
fov_integrated$metaclusters <- factor(fov_integrated@active.ident)

#fov_integrated <- RenameIdents(object = fov_integrated, `Stromal` = "Immune")
#fov_integrated <- RenameIdents(object = fov_integrated, `Other` = "Stromal")

dittoDimPlot(fov_integrated, var = "SCSA_clusters_st1",
             reduction.use = "umap.harmony", size = 1,
             do.label = TRUE, labels.size = 4, labels.highlight = TRUE) +
  theme(legend.title = element_blank()) +
  ggtitle("Epithelial clusters on UMAP")

dittoDimPlot(fov_integrated, var = "SCSA_clusters_st1", split.by = "SCSA_clusters_st1",
             reduction.use = "umap.harmony", size = 1,
             do.label = TRUE, labels.size = 4, labels.highlight = TRUE) +
  theme(legend.title = element_blank()) +
  ggtitle("Epithelial clusters on UMAP")

dittoDimPlot(fov_integrated, var = "metaclusters", split.by = "metaclusters",
             reduction.use = "umap.harmony", size = 1,
             do.label = TRUE, labels.size = 4, labels.highlight = TRUE) +
  theme(legend.title = element_blank()) +
  ggtitle("Epithelial clusters on UMAP")

dittoDimPlot(fov_integrated, var = "IF_type2", split.by = "IF_type2",
             reduction.use = "umap.harmony", size = 1,
             do.label = TRUE, labels.size = 4, labels.highlight = TRUE) +
  theme(legend.title = element_blank()) +
  ggtitle("If cell types on UMAP")

multi_dittoDimPlot(fov_integrated, vars = c("IF_type2","SCSA_clusters_st1"),
                   reduction.use = "umap.harmony", size = 1, ncol=2,
                   do.label = TRUE, labels.size = 4, labels.highlight = TRUE) +
  theme(legend.title = element_blank()) +
  ggtitle("MNN clusters on UMAP")

multi_dittoDimPlot(fov_integrated, vars = c("IF_type2","SCSA_clusters_st1"),
                   reduction.use = "umap.mnn", size = 1, ncol=2,
                   do.label = TRUE, labels.size = 4, labels.highlight = TRUE) +
  theme(legend.title = element_blank()) +
  ggtitle("MNN clusters on UMAP")

# Visualise SCSA labelled clusters in a spatial context
Idents(fov_integrated) <- "SCSA_clusters_st1"
ImageDimPlot(fov_integrated, fov = c("fov02", "fov23"), axes = TRUE, cols = "polychrome", size = 1, boundaries = "segmentation")
ImageDimPlot(fov_integrated, fov = "fov02", group.by = c("IF_type2", "SCSA_clusters_st1"), axes = TRUE, cols = "polychrome", size = 1, boundaries = "segmentation")
ImageDimPlot(fov_integrated, fov = "fov23", group.by = c("IF_type2","SCSA_clusters_st1"), axes = TRUE, cols = "polychrome", size = 1, boundaries = "segmentation")

# Plot frequencies of SCSA labelled clusters per sample
dittoBarPlot(fov_integrated, var = "SCSA_clusters_st1", group.by = "sample_ID",  scale = c("percent")) 
dittoBarPlot(fov_integrated, var = "SCSA_clusters_st1", group.by = "CMS",  scale = c("percent")) 
dittoBarPlot(fov_integrated, var = "SCSA_clusters_st1", group.by = "MMR_Status_Jen",  scale = c("percent")) 
dittoBarPlot(fov_integrated, var = "IF_marker", group.by = "SCSA_clusters_st1",  scale = c("percent"))
dittoBarPlot(fov_integrated, var = "IF_type2", group.by = "SCSA_clusters_st1",  scale = c("percent"))

# Plot normalised protein expression per cluster
DefaultAssay(fov_integrated) <- "Protein"
Idents(fov_integrated) <- "SCSA_clusters_st1"
features <- c("MeanPanCK", "MaxPanCK","MeanCD45", "MaxCD45", "MeanCD3", "MaxCD3")

VlnPlot(fov_integrated, features = features, sort = TRUE, layer = "data", pt.size = 0.001, ncol = 2) + NoLegend() #CLR normalised protein exp
RidgePlot(fov_integrated, features = features, sort = TRUE, ncol = 2)




########################################################################################################################################################################################################################################################################################

# 15- Cluster annotation with correlation-based annotation

# 15.1- Cell Annotation with SingleR

# Reference: https://github.com/dviraran/SingleR
# Reference: https://github.com/LTLA/SingleR/blob/master/README.md
# Reference: Reference-based analysis of lung single-cell sequencing reveals a transitional profibrotic macrophage.
# Reference: https://bioconductor.org/packages/devel/bioc/vignettes/SingleR/inst/doc/SingleR.html
# Reference: http://bioconductor.org/books/release/SingleRBook/
# Reference: https://nbisweden.github.io/excelerate-scRNAseq/session-celltypeid/celltypeid.html

# Example of the use of SingleR() with the Human Primary Cell Atlas dataset (Mabbott et al. 2013) as the reference.
# Loading reference data with Ensembl annotations.
# Each celldex dataset actually has three sets of labels that primarily differ in their resolution. 
# For the purposes of this demonstration, we will use the “fine” labels in the label.fine metadata field, which represents the highest resolution of annotation available for this dataset.
library(celldex)
ref.data <- HumanPrimaryCellAtlasData(ensembl=FALSE)
saveRDS(ref.data, "HumanPrimaryCellAtlasData.rds")
ref.data <- readRDS("./RDS_files/7_Reference_datasets/HumanPrimaryCellAtlasData/HumanPrimaryCellAtlasData.rds")

blueprint <- BlueprintEncodeData(ensembl=FALSE)
saveRDS(hemato, "BlueprintEncodeData.rds")
ref.data2 <- readRDS("./RDS_files/7_Reference_datasets/BlueprintEncodeData/BlueprintEncodeData.rds")

# Human databases in the library celldex:
# HumanPrimaryCellAtlasData - ownload and cache the normalized expression values of the data stored in the Human Primary Cell Atlas.
# BlueprintEncodeData - Download and cache the normalized expression values of 259 RNA-seq samples of pure stroma and immune cells as generated and supplied by Blueprint and ENCODE.
# DatabaseImmuneCellExpressionData - Download and cache the normalized expression values of 1561 bulk RNA-seq samples of sorted cell populations from the Database of Immune Cell Expression (DICE).
# NovershternHematopoieticData - ownload and cache the normalized expression values of 211 bulk human microarray samples of sorted hematopoietic cell populations that can be found in GSE24759.
# Samples were additionally annotated to 38 fine cell types ("label.fine").
# MonacoImmuneData - Download and cache the normalized expression values of 114 bulk RNA-seq samples of sorted immune cell populations

# 15.1.1- Performing predictions. Convert Seurat object to SingleCellExperiment object
library(SingleCellExperiment)
library(scater)
library(SingleR)

DefaultAssay(fov_integrated) <- "RNA" 
Idents(fov_integrated) <- 'harmony_clusters'
levels(fov_integrated)
sce <- as.SingleCellExperiment(fov_integrated, assay = "RNA")
saveRDS(sce, "fov_integrated_sce.rds")

# We perform annotation by calling SingleR() on our test dataset and the reference (ImmGen) dataset, 
# leaving the default of de.method="classic" to use the original marker detection scheme. 
# This applies the algorithm described in Section 1.2, returning a DataFrame where each row contains prediction results for a single cell in the sce object. 
# Labels are provided in the labels column.
# See 'Choices of assay data' for 'assay.type.test=' explanation.

# 15.1.2- Using the HumanPrimaryCellAtlasData ref 

# main labels
pred <- SingleR(test = sce, ref = ref.data, 
                labels = ref.data$label.main, assay.type.test=1)
colnames(pred)
saveRDS(pred, "./fov_integrated_SingleR_pred.rds")
pred <- readRDS("./fov_integrated_SingleR_pred.rds")

# fine labels
pred2 <- SingleR(test = sce, ref = ref.data, 
                 labels = ref.data$label.fine, assay.type.test=1)
colnames(pred2)
saveRDS(pred2, "./fov_integrated_SingleR_pred2.rds")
pred2 <- readRDS("./fov_integrated_SingleR_pred2.rds")

# 15.1.3- Using the Blueprintenconde ref

# main labels
pred3 <- SingleR(test = sce, ref = ref.data2, 
                 labels = ref.data2$label.main, assay.type.test=1)
colnames(pred3)
saveRDS(pred3, "./fov_integrated_SingleR_pred3.rds")
pred3 <- readRDS("./fov_integrated_SingleR_pred3.rds")

# fine labels
pred4 <- SingleR(test = sce, ref = ref.data2, 
                 labels = ref.data2$label.fine, assay.type.test=1)
colnames(pred4)
saveRDS(pred4, "./fov_integrated_SingleR_pred4.rds")
pred4 <- readRDS("./fov_integrated_SingleR_pred4.rds")

# 15.2- Cell Annotation with CIPR

# Reference: https://github.com/atakanekiz/CIPR-Shiny
library(CIPR)
DefaultAssay(fov_integrated) <- "RNA" 
Idents(fov_integrated) <- 'harmony_clusters'
levels(fov_integrated)

# 15.2.1- Calculate average gene expression per cluster
# This is the step where we generate the input for CIPR's all-genes correlation methods
avgexp <- AverageExpression(fov_integrated)
avgexp <- as.data.frame(avgexp$RNA)
avgexp$gene <- rownames(avgexp)
write.csv(avgexp, "avgexp.csv")

# CIPR analysis

# 15.2.2- Standard logFC comparison method
# Immunological Genome Project (ImmGen) microarray data from sorted mouse immune cells. This dataset is prepared by using both V1 and V2 ImmGen releases and it contains 296 samples from 20 different cell types (253 subtypes).
# Mouse RNAseq data from sorted cells reported in Benayoun et al. (2019). This dataset contains 358 sorted immune and nonimmune samples from 18 different lineages (28 subtypes).
# Blueprint/Encode RNAseq data that contains 259 sorted human immune and nonimmune samples from 24 different lineages (43 subtypes).
# Human Primary Cell Atlas that contains microarray data from 713 sorted immune and nonimmune cells (37 main cell types and 157 subtypes).
# DICE (Database for Immune Cell Expression(/eQTLs/Epigenomics) that contains 1561 human immune samples from 5 main cell types (15 subtypes). To reduce object sizes, mean TPM values per cell type is used.
# Human microarray data from sorted hematopoietic cells reported in Novershtern et al. (2011). This dataset contains data from 211 samples and 17 main cell types (38 subtypes)
# Human RNAseq data from sorted cells reported in Monaco et al. (2019). This dataset contains 114 samples originating from 11 main cell types (29 subtypes)
# A custom reference dataset provided by the user. This dataset can be obtained from a number of high througput methods including microarray and bulk RNAseq. For details about how to prepare custom reference, please see the How-to tab on the Shiny website.
        
allmarkers <- read.csv("./Plots/7_Clustering/Option 1/Harmony/Markers_harmony_clusters_RNA.csv")

CIPR(input_dat = allmarkers,
     comp_method = "logfc_dot_product", 
     reference = "hpca", 
     plot_ind = T,
     plot_top = F, 
     global_results_obj = T, 
     global_plot_obj = T,
     # axis.text.x=element_text(color="red") # arguments to pass to ggplot2::theme() to change plotting parameters
)

# Plot identity scores for a select cluster
library(ggplot2)

ind_clu_plots$cluster0 +
  theme(axis.text.y = element_text(color="red"),
        axis.text.x = element_text(color="blue")) +
  labs(fill="Reference")+
  ggtitle("Automated cluster annotation results are shown for cluster 0") +
  annotate("text", label="2 sd range", x=10, y= 500, size=8, color = "steelblue")+
  annotate("text", label= "1 sd range", x=10, y=175, size=8, color ="orange2")+
  geom_rect(aes(xmin=94, xmax=99, ymin=550, ymax=900), fill=NA, linewidth=3, color="red")

# Tabulate CIPR results
# CIPR results (both top 5 scoring reference types per cluster and the entire analysis) are saved as global objects (`CIPR_top_results` and `CIPR_all_results` respectively) to allow users to explore the outputs and generate specific plots and tables.
DT::datatable(CIPR_top_results)
DT::datatable(head(CIPR_all_results))

write.csv(CIPR_top_results, "CIPR_top_results.csv")
write.csv(CIPR_top_results, "CIPR_top_results_avgexp_correlation.csv")
write.csv(CIPR_all_results, "CIPR_all_results.csv")

# 15.2.3- Standard all-genes correlation method
# CIPR also implements a simple correlation approach in which overall correlation in gene expression is calculated for the pairs of unknown clusters and the reference samples (regardless of the differential expression status of the gene). 
# This approach is conceptually similiar to some other automated identity prediction pipelines such as [SingleR](https://www.ncbi.nlm.nih.gov/pubmed/30643263) and [scMCA](https://www.ncbi.nlm.nih.gov/pubmed/30758821).
# Users can select one of the following methods:
# Spearman's correlation:__ It calculates correlation based on ranked gene expression. It can be suitable for comparing experimental and reference data which were obtained using different technologies.
# Pearson's correlation:__ It calculates linear correlations. This can be useful when the user would like to provide a custom reference dataset to CIPR.

CIPR(input_dat = avgexp,
     comp_method = "all_genes_spearman", 
     reference = "hpca", 
     plot_ind = T,
     plot_top = F, 
     global_results_obj = T, 
     global_plot_obj = T)


# 15.2.4- Add SCSA cluster lables
Idents(fov_integrated) <- "harmony_clusters"
levels(fov_integrated)
CIPR_clusters_st1 <- c("Epithelial cell", "Macrophage", "Epithelial cell", "T cell", "Tissue stem cell", "Epithelial cell", "Endothelial cell", "B cell", "Epithelial cell", "Fibroblast", "DC",
                       "Plasma cell", "Epithelial cell", "Monocyte", "Monocyte", "Tissue stem cell","B cell", "B cell", "Plasma cell", "T cell", "Epithelial cell", "Tissue stem cell", "Tissue stem cell",
                       "Monocyte", "B cell") # st1 means clusters from strategy 1
names(CIPR_clusters_st1) <- levels(fov_integrated)
fov_integrated <- RenameIdents(fov_integrated, CIPR_clusters_st1)

# Adding object metadata with
fov_integrated$CIPR_clusters_st1 <- factor(fov_integrated@active.ident)

#fov_integrated <- RenameIdents(object = fov_integrated, `Stromal` = "Immune")
#fov_integrated <- RenameIdents(object = fov_integrated, `Other` = "Stromal")

multi_dittoDimPlot(fov_integrated, vars = c("IF_type2","CIPR_clusters_st1"),
                   reduction.use = "umap.harmony", size = 1, ncol=2,
                   do.label = TRUE, labels.size = 4, labels.highlight = TRUE) +
  theme(legend.title = element_blank()) +
  ggtitle("MNN clusters on UMAP")

multi_dittoDimPlot(fov_integrated, vars = c("SCSA_clusters_st1","CIPR_clusters_st1"),
                   reduction.use = "umap.harmony", size = 1, ncol=2,
                   do.label = TRUE, labels.size = 4, labels.highlight = TRUE) +
  theme(legend.title = element_blank()) +
  ggtitle("MNN clusters on UMAP")

multi_dittoDimPlot(fov_integrated, vars = c("IF_type2","CIPR_clusters_st1"),
                   reduction.use = "umap.mnn", size = 1, ncol=2,
                   do.label = TRUE, labels.size = 4, labels.highlight = TRUE) +
  theme(legend.title = element_blank()) +
  ggtitle("MNN clusters on UMAP")

# Visualise SCSA labelled clusters in a spatial context
Idents(fov_integrated) <- "CIPR_clusters_st1"
ImageDimPlot(fov_integrated, fov = c("fov02", "fov23"), axes = TRUE, cols = "polychrome", size = 1, boundaries = "segmentation")
ImageDimPlot(fov_integrated, fov = "fov02", group.by = c("IF_type2", "CIPR_clusters_st1"), axes = TRUE, cols = "polychrome", size = 1, boundaries = "segmentation")
ImageDimPlot(fov_integrated, fov = "fov23", group.by = c("IF_type2","CIPR_clusters_st1"), axes = TRUE, cols = "polychrome", size = 1, boundaries = "segmentation")

# Plot frequencies of SCSA labelled clusters per sample
dittoBarPlot(fov_integrated, var = "CIPR_clusters_st1", group.by = "sample_ID",  scale = c("percent")) 
dittoBarPlot(fov_integrated, var = "CIPR_clusters_st1", group.by = "CMS",  scale = c("percent")) 
dittoBarPlot(fov_integrated, var = "CIPR_clusters_st1", group.by = "MMR_Status_Jen",  scale = c("percent")) 
dittoBarPlot(fov_integrated, var = "IF_marker", group.by = "CIPR_clusters_st1",  scale = c("percent"))
dittoBarPlot(fov_integrated, var = "IF_type2", group.by = "CIPR_clusters_st1",  scale = c("percent"))

# Plot normalised protein expression per cluster
DefaultAssay(fov_integrated) <- "Protein"
Idents(fov_integrated) <- "CIPR_clusters_st1"
features <- c("MeanPanCK", "MaxPanCK","MeanCD45", "MaxCD45", "MeanCD3", "MaxCD3")

VlnPlot(fov_integrated, features = features, sort = TRUE, layer = "data", pt.size = 0.001, ncol = 2) + NoLegend() #CLR normalised protein exp
RidgePlot(fov_integrated, features = features, sort = TRUE, ncol = 2)

# 15.3- Making custom references with the Nanostring datasets

# Reference: https://github.com/Nanostring-Biostats/CellProfileLibrary/tree/master/Human/Adult
# Reference: https://aekiz.shinyapps.io/CIPR/
# • See code in the file "cipr_ref_prepation.rmd"

# This repo contains a library of "cell profile matrices" - matrices giving the average expression profiles of all cell types found in a tissue. Each matrix in the library was derived from a single scRNA-seq experiment. These matrices can be used with cell type deconvolution packages like SpatialDecon to get cell type proportions or identities.
# Each RData file contains 3 file types:#
# Cell Profile Matrix: average expression profile of all cell types found in a tissue.
# Cell Groups
# Dataset Metadata: Includes database, tissue, age, and paper info
# Matrices were generated using published datasets that had annotated cell types in human and mouse. Datasets were normalized, by total gene count, if raw data was used otherwise the publication’s normalization used. These datasets were filtered for cells expressing (count > 0) at least 100 genes and only calculated cell type profiles for cell types with 15+ viable cells. Profiles were created by taking the average expression of each gene across all viable cells of each cell type.

#log normalise expression
colon_ref <- get(load('./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/Adult/Colon_HCA.Rdata'))
write.csv(x = profile_matrix, file = "colon_ref.csv", row.names = TRUE, quote = FALSE)
colon_ref<- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/colon_ref.csv")

colon_ref2 <- colon_ref[2:12]
colon_ref2 <- NormalizeData(colon_ref2, normalization.method = "LogNormalize", scale.factor = 10000, block.size = NULL, verbose = TRUE)
write.csv(x = colon_ref2, file = "colon_ref2.csv",  row.names = TRUE, quote = FALSE)
colon_ref2 <- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/CIPR/colon_ref2.csv")

#log normalise expression
gut_ref <- get(load('./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/Adult/Gut_HCA.Rdata'))
write.csv(x = profile_matrix, file = "gut_ref.csv", row.names = TRUE, quote = FALSE)
gut_ref<- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/gut_ref.csv")

gut_ref2 <- gut_ref[2:91]
gut_ref2 <- NormalizeData(gut_ref2, normalization.method = "LogNormalize", scale.factor = 10000, block.size = NULL, verbose = TRUE)
write.csv(x = gut_ref2, file = "gut_ref2.csv", row.names = TRUE, quote = FALSE)
gut_ref2 <- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/CIPR/gut_ref2.csv")

#log normalise expression
ileum_ref <- get(load('./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/Adult/Ileum_Wang.Rdata'))
write.csv(x = profile_matrix, file = "ileum_ref.csv",  row.names = TRUE, quote = FALSE)
ileum_ref<- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/ileum_ref.csv")

ileum_ref2 <- ileum_ref[2:8]
ileum_ref2 <- NormalizeData(ileum_ref2, normalization.method = "LogNormalize", scale.factor = 10000, block.size = NULL, verbose = TRUE)
write.csv(x = ileum_ref2, file = "ileum_ref2.csv", row.names = TRUE, quote = FALSE)
ileum_ref2 <- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/CIPR/ileum_ref2.csv")

#log normalise expression
rectum_ref <- get(load('./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/Adult/Rectum_Wang.Rdata'))
write.csv(x = profile_matrix, file = "rectum_ref.csv", 
          row.names = TRUE, quote = FALSE)
rectum_ref<- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/rectum_ref.csv")
rectum_ref <- as.data.frame(rectum_ref)

rectum_ref2 <- rectum_ref[2:8]
rectum_ref2 <- NormalizeData(rectum_ref2, normalization.method = "LogNormalize", scale.factor = 10000, block.size = NULL, verbose = TRUE)
write.csv(x = rectum_ref2, file = "rectum_ref2.csv", row.names = TRUE, quote = FALSE)
rectum_ref2 <- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/CIPR/rectum_ref2.csv")

#log normalise expression
immunetumor_ref <- get(load('./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/Adult/ImmuneTumor_safeTME.Rdata'))
write.csv(x = profile_matrix, file = "immunetumor_ref.csv", 
          row.names = TRUE, quote = FALSE)
immunetumor_ref<- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/immunetumor_ref.csv")

immunetumor_ref2 <- immunetumor_ref[2:19]
immunetumor_ref2 <- NormalizeData(immunetumor_ref2, normalization.method = "LogNormalize", scale.factor = 10000, block.size = NULL, verbose = TRUE)
write.csv(x = immunetumor_ref2, file = "immunetumor_ref2.csv", row.names = TRUE, quote = FALSE)
immunetumor_ref2 <- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/CIPR/immunetumor_ref2.csv")

# Annotation with CIPR
allmarkers <- read.csv("./Plots/7_Clustering/Option 1/Harmony/Markers_harmony_clusters_RNA.csv")
allmarkers <- as.data.frame(allmarkers)

merged <- merge(colon_ref2, gut_ref2, by.x = "Gene", by.y = "Gene") # gave the best performance for the annotation
merged2 <- merge(merged, ileum_ref2, by.x = "Gene", by.y = "Gene")
merged3 <- merge(merged, rectum_ref2, by.x = "Gene", by.y = "Gene")
merged4 <- merge(merged, immunetumor_ref2, by.x = "Gene", by.y = "Gene")

CIPR(input_dat = avgexp,
     comp_method = "all_genes_spearman", 
     reference = "custom",
     custom_reference = merged,  
     plot_ind = F,
     plot_top = T, 
     global_results_obj = T, 
     global_plot_obj = F)

write.csv(CIPR_top_results, "CIPR_top_results_colon_gut_refs.csv")
write.csv(CIPR_all_results, "CIPR_all_results_colon_gut_refs.csv")

# 15.2.4- Add SCSA cluster lables
Idents(fov_integrated) <- "harmony_clusters"
levels(fov_integrated)
CIPR_clusters_st1_v2 <- c("Epithelial cell", "MMP9+ Inflammatory Macrophage", "Epithelial cell", "Epithelial cell", "Fibroblast", "Epithelial cell", "Endothelial cell", "B cell", "Epithelial cell", "Fibroblast", "Stem cell",
                       "Epithelial cell", "Epithelial cell", "Monocyte", "Monocyte", "Tissue stem cell","Plasma cell", "Plasma cell", "Plasma cell", "ILC3", "Epithelial cell", "Endothelial cell", "Tissue stem cell",
                       "Monocyte", "Plasma cell") # st1 means clusters from strategy 1
names(CIPR_clusters_st1_v2) <- levels(fov_integrated)
fov_integrated <- RenameIdents(fov_integrated, CIPR_clusters_st1_v2)

# Adding object metadata with
fov_integrated$CIPR_clusters_st1_v2 <- factor(fov_integrated@active.ident)

multi_dittoDimPlot(fov_integrated, vars = c("SCSA_clusters_st1","CIPR_clusters_st1", "CIPR_clusters_st1_v2"),
                   reduction.use = "umap.harmony", size = 1, ncol=2,
                   do.label = TRUE, labels.size = 4, labels.highlight = TRUE) +
  theme(legend.title = element_blank()) +
  ggtitle("MNN clusters on UMAP")

# Visualise SCSA labelled clusters in a spatial context
Idents(fov_integrated) <- "CIPR_clusters_st1_v2"
ImageDimPlot(fov_integrated, fov = c("fov02", "fov23"), axes = TRUE, cols = "polychrome", size = 1, boundaries = "segmentation")

# Plot frequencies of SCSA labelled clusters per sample
dittoBarPlot(fov_integrated, var = "CIPR_clusters_st1_v2", group.by = "sample_ID",  scale = c("percent")) 
dittoBarPlot(fov_integrated, var = "CIPR_clusters_st1_v2", group.by = "CMS",  scale = c("percent")) 
dittoBarPlot(fov_integrated, var = "CIPR_clusters_st1_v2", group.by = "MMR_Status_Jen",  scale = c("percent")) 
dittoBarPlot(fov_integrated, var = "IF_marker", group.by = "CIPR_clusters_st1_v2",  scale = c("percent"))
dittoBarPlot(fov_integrated, var = "IF_type2", group.by = "CIPR_clusters_st1_v2",  scale = c("percent"))

# Plot normalised protein expression per cluster
DefaultAssay(fov_integrated) <- "Protein"
Idents(fov_integrated) <- "CIPR_clusters_st1_v2"
features <- c("MeanPanCK", "MaxPanCK","MeanCD45", "MaxCD45", "MeanCD3", "MaxCD3")

VlnPlot(fov_integrated, features = features, sort = TRUE, layer = "data", pt.size = 0.001, ncol = 2) + NoLegend() #CLR normalised protein exp
RidgePlot(fov_integrated, features = features, sort = TRUE, ncol = 2)

########################################################################################################################################################################################################################################################################################

# 16- Cluster annotation with supervised classiﬁcation

# 16.1- Cell Annotation with CHETAH (CHaracterization of cEll Types Aided by Hierarchical classification)

# Reference: https://github.com/jdekanter/CHETAH
# http://www.bioconductor.org/packages/devel/bioc/vignettes/CHETAH/inst/doc/CHETAH_introduction.html
# Cell types are assigned by correlating the input data to a reference in a hierarchical manner. 
# This creates the possibility of assignment to intermediate types if the data does not allow to fully classify to one of the types in the reference.
# CHETAH is built to work with scRNA-seq references, but will also work (with limited capabilities) with RNA-seq or micro-array reference datasets.
# to run CHETAH, you will only need: your input data and a reference dataset, annotated with cell types. Both as a SingleCellExperiment.
# CHETAH constructs a classification tree by hierarchically clustering the reference data. The classification is guided by this tree. In each node of the tree, input cells are either assigned to the right, or the left branch. A confidence score is calculated for each of these assignments. When the confidence score for an assignment is lower than the threshold (default = 0.1), the classification for that cell stops in that node.
library(CHETAH)

# 16.1.1- Preparing the input data
# For the input we define a "counts" assay and "TSNE" or "UMAP" for reduced dimensions
library(SingleCellExperiment)
library(scater)

DefaultAssay(fov_integrated) <- "RNA" 
Idents(fov_integrated) <- 'harmony_clusters'
levels(fov_integrated)
sce <- as.SingleCellExperiment(fov_integrated, assay = "RNA")
saveRDS(sce, "fov_integrated_sce.rds")

# Load CHETAH reference
chetah_ref <- get(load('./RDS_files/7_Reference_datasets/Chetah_reference/CHETAH_TME_reference.Rdata'))

# Running CHETAH
sce <- CHETAHclassifier(input = sce, ref_cells = colon_gut_ref, thresh = 0.1) # it took 2h to run...

# output
# CHETAH returns the input object, but added: input$celltype_CHETAH - a named character vector that can directly be used in any other workflow/method.
# “hidden” int_colData and int_metadata, not meant for direct interaction, but which can all be viewed and interacted with using: PlotCHETAH and CHETAHshiny
PlotCHETAH(input = sce, redD = "UMAP.HARMONY")

# 16.1.3- Preparing the customised reference
# http://www.bioconductor.org/packages/devel/bioc/vignettes/CHETAH/inst/doc/CHETAH_introduction.html#ref-prep
# The reference data has to be normalized beforehand.
# Reference QC: The performance of CHETAH is heavily dependent on the quality of the reference. The quality of the reference is affected by:
# the quality of the scRNA-seq data
# the accuracy of the cell type labels
# To see how well CHETAH can distinguish between the cell types in a reference, CorrelateReference and more importantly ClassifyReference can be run.

# Customised colon reference data:
colon_ref2 <- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/CIPR/colon_ref2.csv")
colon_ref3 <- colon_ref2[,-1]
rownames(colon_ref3) <- colon_ref2$Gene
colon_ref3 <- as.matrix(colon_ref3)
class(colon_ref3)
celltypes_colon <- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/CIPR/celltypes_colon.csv", header = FALSE)
celltypes_colon <- as.matrix(celltypes_colon)
celltypes_colon <- as.vector(celltypes_colon)
str(celltypes_colon)
all.equal(names(celltypes_colon), colnames(colon_ref3)) 
colon_ref <- SingleCellExperiment(assays = list(counts = colon_ref3), colData = DataFrame(celltypes = celltypes_colon))
saveRDS(colon_ref, "colon_ref_chetah.rds")

# Customised gut reference data:
gut_ref2 <- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/CIPR/gut_ref2.csv")
gut_ref3 <- gut_ref2[,-1]
rownames(gut_ref3) <- gut_ref2$Gene
gut_ref3 <- as.matrix(gut_ref3)
class(gut_ref3)
celltypes_gut <- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/CIPR/celltypes_gut.csv", header = FALSE)
celltypes_gut <- as.matrix(celltypes_gut)
celltypes_gut <- as.vector(celltypes_gut)
str(celltypes_gut)
all.equal(names(celltypes_gut), colnames(gut_ref3)) 
gut_ref <- SingleCellExperiment(assays = list(counts = gut_ref3), colData = DataFrame(celltypes = celltypes_gut))
saveRDS(gut_ref, "gut_ref_chetah.rds")
gut_ref <- readRDS("./gut_ref_chetah.rds")

# Customised ileum reference data:
ileum_ref2 <- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/CIPR/ileum_ref2.csv")
ileum_ref3 <- ileum_ref2[,-1]
rownames(ileum_ref3) <- ileum_ref2$Gene
ileum_ref3 <- as.matrix(ileum_ref3)
class(ileum_ref3)
celltypes_ileum <- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/CIPR/celltypes_ileum.csv", header = FALSE)
celltypes_ileum <- as.matrix(celltypes_ileum)
celltypes_ileum <- as.vector(celltypes_ileum)
str(celltypes_ileum)
all.equal(names(celltypes_ileum), colnames(ileum_ref3)) 
ileum_ref <- SingleCellExperiment(assays = list(counts = ileum_ref3), colData = DataFrame(celltypes = celltypes_ileum))
saveRDS(ileum_ref, "ileum_ref_chetah.rds")

# Customised rectum reference data:
rectum_ref2 <- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/CIPR/rectum_ref2.csv")
rectum_ref3 <- rectum_ref2[,-1]
rownames(rectum_ref3) <- rectum_ref2$Gene
rectum_ref3  <- as.matrix(rectum_ref3)
class(rectum_ref3)
celltypes_rectum <- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/CIPR/celltypes_rectum.csv", header = FALSE)
celltypes_rectum <- as.matrix(celltypes_rectum)
celltypes_rectum <- as.vector(celltypes_rectum)
str(celltypes_rectum)
all.equal(names(celltypes_rectum), colnames(rectum_ref3)) 
rectum_ref <- SingleCellExperiment(assays = list(counts = rectum_ref3), colData = DataFrame(celltypes = celltypes_rectum))
saveRDS(rectum_ref, "rectum_ref_chetah.rds")

# Customised immunetumor reference data:
immunetumor_ref2 <- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/CIPR/immunetumor_ref2.csv")
immunetumor_ref3 <- immunetumor_ref2[,-1]
rownames(immunetumor_ref3) <- immunetumor_ref2$Gene
immunetumor_ref3  <- as.matrix(immunetumor_ref3)
class(immunetumor_ref3)
celltypes_immunetumor <- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/CIPR/celltypes_immunetumor.csv", header = FALSE)
celltypes_immunetumor <- as.matrix(celltypes_immunetumor)
celltypes_immunetumor <- as.vector(celltypes_immunetumor)
str(celltypes_immunetumor)
all.equal(names(celltypes_immunetumor), colnames(immunetumor_ref3)) 
immunetumor_ref <- SingleCellExperiment(assays = list(counts = immunetumor_ref3), colData = DataFrame(celltypes = celltypes_immunetumor))
saveRDS(immunetumor_ref, "immunetumor_ref_chetah.rds")

# Customised merged colon and gut refs data:
merged <- merge(colon_ref2, gut_ref2, by.x = "Gene", by.y = "Gene") # gave the best performance for the annotation
write.csv(x = merged, file = "colon_gut_ref2.csv", row.names = TRUE, quote = FALSE)

colon_gut_ref2 <- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/CIPR/colon_gut_ref2.csv")
colon_gut_ref3 <- colon_gut_ref2[,-1]
rownames(colon_gut_ref3) <- colon_gut_ref2$Gene
colon_gut_ref3  <- as.matrix(colon_gut_ref3)
class(colon_gut_ref3)
celltypes_colon_gut <- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/CIPR/celltypes_colon_gut.csv", header = FALSE)
celltypes_colon_gut <- as.matrix(celltypes_colon_gut)
celltypes_colon_gut <- as.vector(celltypes_colon_gut)
str(celltypes_colon_gut)
all.equal(names(celltypes_colon_gut), colnames(colon_gut_ref3)) 
colon_gut_ref <- SingleCellExperiment(assays = list(counts = colon_gut_ref3), colData = DataFrame(celltypes = celltypes_colon_gut))
saveRDS(colon_gut_ref, "colon_gut_ref_chetah.rds")

# A- CorrelateReference
# for every combination of two cell types, finds the genes with the highest fold-change between the two and uses these to correlate them to each other. 
# If the reference is good, all types will correlate poorly or even better, will anti-correlate.
CorrelateReference(ref_cells = immunetumor_ref)

# B- ClassifyReference
# Another check to see whether CHETAH can distinguish between the cell types in the reference is ClassifyReference. 
# This function uses the reference to classify the reference itself. If CHETAH works well with the reference, there should be almost no mix-ups in the classification, i.e. all cells of type A should be classified to type A.
ClassifyReference(ref_cells = immunetumor_ref)


# 16.2- Cell Annotation with InSituType

# Reference: file:///Users/joaoluizsfilho/Packages/scRNAseq/InSituType-main/vignettes/NSCLC-semi-supervised-cell-typing-vignette.html
library(InSituType)

# 16.2.1- Preparing reference matrixes

# Use the original references from the CellProfileLibrary
# Necessary inputs: matrix of counts data, cells x genes in the SingleCelllExperiment format
# A “reference matrix” giving the expected expression profile of each cell type, with genes in rows and cell types in columns. 
# The reference matrix must be in linear-scale, not log-scale. Insitutype can handle aligning its genes (rows) to your counts matrix. 
# For supervised cell typing, the reference matrix should contain every cell type present in the tissue. 
# If you suspect the tissue has cell types outside your reference matrix, use insitutype’s semi-supervised clustering capability.
# Customised colon reference data:
colon_ref2 <- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/Insitutype/colon_ref.csv", sep=",", row.names=0)
colon_ref3 <- as.matrix(colon_ref2)
class(colon_ref3)
str(colon_ref3)
saveRDS(colon_ref3, "colon_ref_insitutype.rds")

# Customised gut reference data:
gut_ref2 <- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/Insitutype/gut_ref.csv", sep=",", row.names=1)
gut_ref3 <- as.matrix(gut_ref2)
class(gut_ref3)
str(gut_ref3)
saveRDS(gut_ref3, "gut_ref_insitutype.rds")

# Customised ileum reference data:
ileum_ref2 <- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/Insitutype/ileum_ref.csv", sep=",", row.names=1)
ileum_ref3 <- as.matrix(ileum_ref2)
class(ileum_ref3)
str(ileum_ref3)
saveRDS(ileum_ref3, "ileum_ref_insitutype.rds")

# Customised rectum reference data:
rectum_ref2 <- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/Insitutype/rectum_ref.csv", sep=",", row.names=1)
rectum_ref3  <- as.matrix(rectum_ref2)
class(rectum_ref3)
str(rectum_ref3)
saveRDS(rectum_ref3, "rectum_ref_insitutype.rds")

# Customised immunetumor reference data:
immunetumor_ref2 <- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/Insitutype/immunetumor_ref.csv", sep=",", row.names=1)
immunetumor_ref3  <- as.matrix(immunetumor_ref2)
class(immunetumor_ref3)
str(immunetumor_ref3)
saveRDS(immunetumor_ref3, "immunetumor_ref_insitutype.rds")

# Customised merged colon and gut refs data:
merged <- merge(colon_ref2, gut_ref2, by.x = "Gene", by.y = "Gene") # gave the best performance for the annotation
write.csv(x = merged, file = "colon_gut_ref.csv", row.names = TRUE, quote = FALSE)

colon_gut_ref2 <- read.csv("./RDS_files/7_Reference_datasets/CellProfileLibrary/Human/Insitutype/colon_gut_ref.csv", sep=",", row.names=1)
colon_gut_ref3  <- as.matrix(colon_gut_ref2)
str(colon_gut_ref3)
saveRDS(colon_gut_ref3, "colon_gut_ref_insitutype.rds")

# 16.2.2- Extract the count matrix with the negative probe expression and calculate cells background
counts <- LayerData(fov_subset, assay = "RNA")
neg <- counts[(which(rownames(counts) %in% c('NegPrb3',	'NegPrb5', 'NegPrb6',	'NegPrb7', 'NegPrb8',	'NegPrb9', 'NegPrb10',	'NegPrb11',	'NegPrb12',	'NegPrb13',	'NegPrb14',	'NegPrb15',	'NegPrb16', 'NegPrb18',	'NegPrb19',	'NegPrb20',	'NegPrb21',	'NegPrb22',	'NegPrb23'))),]
saveRDS(neg, "negative_counts.rds")

# cells should be in rows and genes in columns
counts <- as.matrix(counts)
str(counts)
counts <- t(counts)
str(counts)

neg <- as.matrix(neg)
neg <- t(neg)
str(neg)

# Vector giving each cell’s mean negative control value:
negmean <- Matrix::rowMeans(neg)
head(negmean)

# estimate per-cell bg as a fraction of total counts:
negmean.per.totcount <- mean(negmean) / mean(rowSums(counts))
per.cell.bg <- rowSums(counts) * negmean.per.totcount

# 16.2.3- Updating the reference profiles to account for platform effects

# As in most cases, our reference matrix was derived using a different platform. As such, it will be a noisy representation of what cells will look like in CosMx data.
# To avoid disadvantaging our reference cell types compared to newly-derived clusters, we’ll have to update the reference profiles to better fit CosMx data.
# 1. Identify “anchor cells”: cells that can confidently be assigned to a reference cell type. Anchor cells can be hand-selected based on marker genes or morphology. But for most cases, they will be selected using the data-driven approach implemented below. 
# 2. Estimate the mean profile of each cell type’s anchors. These mean profiles form the updated reference matrix.
# This step is slow for big datasets. It's recommended to run this once and save the results. Then you can iteratively adjust your choices when selecting anchor cells)


astats <- get_anchor_stats(counts = counts,
                           neg = negmean,
                           profiles = colon_gut_ref3)
saveRDS(astats, "anchor_stats_insitutype.rds")

# now choose anchors:
anchors <- choose_anchors_from_stats(counts = counts, 
                                     neg = negmean, 
                                     bg = per.cell.bg,
                                     anchorstats = astats, 
                                     # a very low value chosen for the mini
                                     # dataset. Typically hundreds of cells
                                     # would be better.
                                     n_cells = 50, 
                                     min_cosine = 0.4, 
                                     min_scaled_llr = 0.03, 
                                     insufficient_anchors_thresh = 5)

# plot the anchors atop the UMAP:
par(mfrow = c(1, 1))
plot(sce$UMAP.HARMONY, pch = 16, cex = 0.1, col = "peachpuff1", xaxt = "n",  yaxt = "n", xlab = "", ylab = "",
     main = "Selected anchor cells")
points(sce$UMAP.HARMONY[!is.na(anchors), ], col = iocolors[anchors[!is.na(anchors)]], pch = 16, cex = 0.6)
legend("topright", pch = 16, col = iocolors[setdiff(unique(anchors), NA)], legend = setdiff(unique(anchors), NA), cex = 0.65)


# 16.2.4- Semi-supervised cell annotation
updatedprofiles <- updateReferenceProfiles(reference_profiles = colon_gut_ref3, 
                                           counts = counts, 
                                           neg = neg, 
                                           bg = per.cell.bg,
                                           anchors = anchors) 
str(updatedprofiles)

# OTHER OPTION TO RUN WITHOUT ANCHORS
updatedprofiles <- updateReferenceProfiles(reference_profiles = colon_gut_ref3, 
                                           counts = counts, 
                                           neg = neg, 
                                           bg = per.cell.bg,
                                           anchors = NULL) 

Insitutype_clusters_st1 <- updatedprofiles$anchors
write.csv(Insitutype_clusters_st1, "insituclusters.csv")

fov_integrated@meta.data <-cbind(fov_integrated@meta.data, Insitutype_clusters_st1)

Idents(fov_integrated) <- "Insitutype_clusters_st1"
levels(fov_integrated)

multi_dittoDimPlot(fov_integrated, vars = c("SCSA_clusters_st1","CIPR_clusters_st1", "CIPR_clusters_st1_v2", "Insitutype_clusters_st1"),
                   reduction.use = "umap.harmony", size = 1, ncol=2,
                   do.label = TRUE, labels.size = 1, labels.highlight = TRUE) +
  theme(legend.title = element_blank()) +
  ggtitle("Clusters on UMAP")

dittoDimPlot(fov_integrated, var = "Insitutype_clusters_st1",
                   reduction.use = "umap.harmony", size = 1,
                   do.label = TRUE, labels.size = 2, labels.highlight = TRUE) +
  theme(legend.title = element_blank()) +
  ggtitle("Clusters on UMAP")

# Visualise SCSA labelled clusters in a spatial context
ImageDimPlot(fov_integrated, fov = c("fov02"), axes = TRUE, cols = "polychrome", size = 1, boundaries = "segmentation")
ImageDimPlot(fov_integrated, fov = c("fov23"), axes = TRUE, cols = "polychrome", size = 1, boundaries = "segmentation")

# 16.2.5- Supervised cell annotation
sup <- insitutypeML(x = counts,
                    neg = negmean,
                    reference_profiles = colon_gut_ref3)   

Insitutype_clusters_st1_v2 <- sup$clust
write.csv(Insitutype_clusters_st1_v2, "insituclusters_supervised.csv")

fov_integrated@meta.data <-cbind(fov_integrated@meta.data, Insitutype_clusters_st1_v2)

Idents(fov_integrated) <- "Insitutype_clusters_st1_v2"
levels(fov_integrated)

multi_dittoDimPlot(fov_integrated, vars = c("SCSA_clusters_st1","CIPR_clusters_st1", "CIPR_clusters_st1_v2", "Insitutype_clusters_st1"),
                   reduction.use = "umap.harmony", size = 1, ncol=2,
                   do.label = TRUE, labels.size = 2, labels.highlight = TRUE) +
  theme(legend.title = element_blank()) +
  ggtitle("Clusters on UMAP")

dittoDimPlot(fov_integrated, var = "Insitutype_clusters_st1_v2",
             reduction.use = "umap.harmony", size = 1,
             do.label = TRUE, labels.size = 2, labels.highlight = TRUE) +
  theme(legend.title = element_blank()) +
  ggtitle("Clusters on UMAP")

# Visualise SCSA labelled clusters in a spatial context
ImageDimPlot(fov_integrated, fov = c("fov02"), axes = TRUE, cols = "polychrome", size = 1, boundaries = "segmentation")
ImageDimPlot(fov_integrated, fov = c("fov23"), axes = TRUE, cols = "polychrome", size = 1, boundaries = "segmentation")

fp <- flightpath_plot(flightpath_result = NULL, insitutype_result = sup)
class(fp)
print(fp)

# Updating clustering results
# After close review, you might want to update your clustering results.
# The function refineClusters can modify your results in the following ways:
# merge closely-related or frequently-confused clusters
# delete clusters (Sometimes a “catch-all” cluster arises that is frequently confused wiht multiple other clusters. It’s best to delete these clusters and let their cells get reassigned to meaningful clusters.)
# sub-cluster large clusters
# Here we use the refineClusters function to perform all these operations. We also use its “merges” argument to rename cluster c. 

# refine the clusters:
newclusts <- refineClusters(
  logliks = semisup$logliks,
  merges = c("fibroblast" = "stroma", "endothelial" = "stroma"),
  to_delete = c("a"),
  # subclustering via refineClusters is not recommended for semi-supervised
  # results
  subcluster = NULL,
  counts = counts,
  neg = negmean
) 
str(newclusts)




# 16.3- Cell Annotation with Garnett

# 16.3.1- Build the CDS object - see Monocle documentation for help

# http://cole-trapnell-lab.github.io/monocle-release/docs/#the-celldataset-class
# https://cole-trapnell-lab.github.io/monocle3/docs/getting_started/#cell_data_set


# The CellDataSet class:
# Because Garnett builds on Monocle 3, data for Garnett is held in objects of the cell_data_set (CDS) class. 
# This class is derived from the Bioconductor SingleCellExperiment class, which provides a common interface familiar to those who have analyzed single-cell data with Bioconductor. 
#Monocle 3 provides detailed documentation about how to generate an input CDS here.

# Monocle holds single cell expression data in objects of the CellDataSet class. 
# The class requires three input files:
# exprs, a numeric matrix of expression values, where rows are genes, and columns are cells
# phenoData, an AnnotatedDataFrame object, where rows are cells, and columns are cell attributes (such as cell type, culture condition, day captured, etc.)
# featureData, an AnnotatedDataFrame object, where rows are features (e.g. genes), and columns are gene attributes, such as biotype, gc content, etc.

# The expression value matrix must:
# have the same number of columns as the phenoData has rows.
# have the same number of rows as the featureData data frame has rows.

# Additionally:
# row names of the phenoData object should match the column names of the expression matrix.
# row names of the featureData object should match row names of the expression matrix.
# one of the columns of the featureData should be named "gene_short_name".
# this function was built for gene names, so convert protein IDs to gene Symbols from ENSEMBL

# Option 1 - convert Seurat object to SCE object
sce <- as.SingleCellExperiment(fov_integrated, assay = "RNA")

sce <- readRDS("./sce.rds")
saveRDS(sce, "./sce.rds")

expr_matrix <- counts(sce) #exprs matrix based on the raw RNA (UMI) counts. THIS IS IMPORTANT! DO NOT USE NORMALISED DATA!

# convert to sparse matrix class dgMatrix
# expr_matrix <- Matrix(expr_matrix, sparse = TRUE)
# writeMM(expr_matrix, "expr_matrix.mtx")
# write.table(expr_matrix,"expr_matrix.txt",sep="\t",row.names=FALSE)

pData <- colData(sce) #cells and their metadata
write.table(pData,"pdata.txt",sep="\t",row.names=FALSE)
pdata <- read.delim("pdata.txt")
pdata <- as.data.frame(pdata)
#pdata <- new("AnnotatedDataFrame", data = pdata)

fData <- rownames(sce)
write.table(fData,"fdata.txt",sep="\t",row.names=FALSE)
fdata <- read.delim("fdata.txt") # metadata of proteins - change column name to gene_short_name in the original panel.csv file
fdata <- as.data.frame(fdata)
#fdata <- new("AnnotatedDataFrame", data = fdata)

colnames(expr_matrix) <- rownames(pdata) #this is important
rownames(expr_matrix) <- fdata$gene_short_name
rownames(fdata) <- rownames(expr_matrix) #this is important

monocle_cds <- new_cell_data_set(as(expr_matrix, "dgCMatrix"),
                                 cell_metadata = pdata,
                                 gene_metadata = fdata)

saveRDS(monocle_cds, "monocle_cds.rds")
monocle_cds <- readRDS("./monocle_cds.rds")

# Option 2 - Extract data, phenotype data, and feature data from the SeuratObject
# https://github.com/cole-trapnell-lab/monocle-release/issues/262

data <- as(as.matrix(fov_integrated@assays$RNA@counts), 'sparseMatrix') # if you do have UMI data, you should not normalize it yourself prior to creating your CellDataSet. Use the raw RNA counts.
pd <- new('AnnotatedDataFrame', data = fov_integrated@meta.data)
fData <- data.frame(gene_short_name = row.names(data), row.names = row.names(data))
fd <- new('AnnotatedDataFrame', data = fData)

#Construct monocle cds
monocle_cds2 <- new_CellData_Set(data,
                                 phenoData = pd,
                                 featureData = fd,
                                 expressionFamily = negbinomial())

saveRDS(monocle_cds2, "monocle_cds2.rds")
monocle_cds2 <- readRDS("./monocle_cds2.rds")


# 8.2- Automated annotation with Garnett 
# Reference: https://cole-trapnell-lab.github.io/monocle3/docs/clustering/#garnett
# https://cole-trapnell-lab.github.io/garnett/docs_m3/

# 8.2.1- Constructing a marker file
# Create a Colon_markers.txt file based on the scRNAseq colon paper. 
# As done in Giotto, create a file resulted from the matching of the top expressed genes per cluster from Seurat with the top expressed genens per cluster listed by the paper.
# List of marker genes from the paper: E-MTAB-8410.marker_genes_inferred_cell_type_-_ontology_labels
# Create a list of marker genes per cluster from Seurat. Use assay = RNA and slot = data to calculate the expressed genes and select only the positively expressed genes. 
# Seurat marker list file: 
DefaultAssay(fov_integrated) <- "RNA" # much more marker genes than with SCT slot
fov_integrated.marker <- FindAllMarkers(object = fov_integrated, only.pos = TRUE, logfc.threshold = 0.25)
clipr::write_clip(fov_integrated.marker) # Copies the table to the clipboard. Go to excel and press cmd+V (mac) or ctrl+V (windows) to paste

# Match features from cosmx to the reference marker gene list
markers_ref <- read.csv("./E-MTAB-8410.marker_genes_inferred_cell_type_-_ontology_labels.csv")

ortho <- markers_ref
cluster <- fov_integrated.marker
idx <- match(ortho$geneID, cluster$gene)
ortho$gene <- cluster$gene[ idx ]
ortho <- na.omit(ortho) 
write.csv(ortho, "cluster_marker_genes_reference_cosmx_matched.csv")

# Exclude genes that are good markers for more than one cell type:

garnett_markers <- ortho %>% 
  group_by(gene) %>%
  filter(n() == 1)

write.csv(garnett_markers, "specific_cluster_marker_genes_reference_cosmx_matched.csv")

system.file(package = "garnett")
marker_file_path <- system.file("extdata", "Colon_cluster_markers.txt", #save marker files in this directory
                                package = "garnett")


# 8.2.2- Checking your markers
# Because defining the marker file is often the hardest part of the process, 
# Garnett includes functions to check whether your markers are likely to work well. 
# The two functions relevant are check_markers and plot_markers. 
# Check_markers generates a table of information about your markers and plot_markers plots the most relevant information.
# In addition to the small included dataset, we have included two example marker files with the package. 

marker_check <- check_markers(cds = monocle_cds, marker_file_path, #check markers file in the Visual Studio Code if there are errors with typing
                              db=org.Hs.eg.db,
                              cds_gene_id_type = "SYMBOL",
                              marker_file_gene_id_type = "SYMBOL")
plot_markers(marker_check)

write.csv(marker_check, "Check_colon_cluster_v1.csv")

# Several genes showed high ambiguity. 
# Remove genes with high ambiguity or check in the matched reference which cell type its expression based on logFC is higher and use to define that particular cell type.  

# 8.2.3- Train the classifier
# Now it's time to train the classifier. The arguments should be pretty close to those for check_markers. 
# The one parameter I am changing from default below is the num_unknown argument. 
# This tells Garnett how many outgroup cells it should compare against. 
# The default is 500, but in this toy dataset with so few cells we want fewer.

set.seed(260)
classifier <- train_cell_classifier(cds = monocle_cds,
                                    marker_file = marker_file_path,
                                    db=org.Hs.eg.db,
                                    cds_gene_id_type = "SYMBOL", #convert protein symbols to geneID symbols in the original files generating the cds object
                                    num_unknown = 50,
                                    marker_file_gene_id_type = "SYMBOL", cores = 4)

saveRDS(classifier, "Garnett_classifier.rds")

#3.2.5- Viewing the classification genes
#Garnett classification is trained using a multinomial elastic-net regression. 
#This means that certain genes are chosen as the relevant genes for distinguishing between cell types. 
#Which genes are chosen may be of interest, so Garnett includes a function to access the chosen genes. 
#Note: Garnett does not regularize the input markers, so they will be included in the classifier regardless.
#The function we use to see the relevant genes is get_feature_genes. 
#The arguments are the classifier, which node you'd like to view (if your tree is hierarchical) - use "root" for the top node and the parent cell type name for other nodes, and the db for your species.
#The function will automatically convert the gene IDs to SYMBOL if you set convert_ids = TRUE.

feature_genes <- get_feature_genes(classifier, 
                                   node = "root",
                                   db = org.Hs.eg.db, convert_ids = TRUE)
head(feature_genes)

# 8.2.3- Classifying cells

monocle_cds <- classify_cells(monocle_cds, classifier,
                              db = org.Hs.eg.db,
                              cluster_extend = TRUE,
                              cds_gene_id_type = "SYMBOL")

head(pData(monocle_cds))
table(pData(monocle_cds)$cell_type)
table(pData(monocle_cds)$cluster_ext_type)
saveRDS(monocle_cds, "monocle_cds.rds")

# 8.2.4-Store labels of classified cells in Spatial Experiment object

cell_labels <- pData(monocle_cds)$cell_type
fov_integrated$cell_type <- cell_labels
table(fov_integrated$cell_type)

# Save the updated Seurat object.
saveRDS(fov_integrated, "fov_integrated.rds")

# 8.2.5- Visualisation of annotated clusters using Garnett

Idents(fov_integrated) <- 'seurat_clusters'
levels(fov_integrated)
ImageDimPlot(fov_integrated, fov = "Primary_fov01", group.by = "cell_type", axes = TRUE, cols = "polychrome", size = 1, boundaries = "segmentation")
ImageDimPlot(fov_integrated, fov = "Metastasis_fov22", group.by = "cell_type", axes = TRUE, cols = "polychrome", size = 1, boundaries = "segmentation")

# UMAP of the identified clusters
DimPlot(fov_integrated, reduction = "umap", label = FALSE) #try other ploting packages and explore the function

dittoDimPlot(fov_integrated, var = "cell_type",
             reduction.use = "umap", size = 1,
             do.label = TRUE, labels.size = 4, labels.highlight = TRUE) +
  theme(legend.title = element_blank()) +
  ggtitle("Cell identities on UMAP")

# Find top expressed genes by the Unknown cluster - looks like epithelial cells
DefaultAssay(fov_integrated) <- "RNA" # much more marker genes than with SCT slot
Idents(fov_integrated) <- 'cell_type'
Unknown_marker <- FindMarkers(fov_integrated, assay = "RNA", slot = "data", ident.1 = "Unknown", only.pos = TRUE, logfc.threshold = 0.1)
clipr::write_clip(Unknown_marker) # Copies the table to the clipboard. Go to excel and press cmd+V (mac) or ctrl+V (windows) to paste

colnames(fov_integrated[[]])
Idents(fov_integrated) <- 'cell_type'
levels(fov_integrated)

# Rename idents of dsb clusters 
cell_type_edited <- c("B cell", "Goblet cell", "T cell",                                     
                      "Plasma cell", "Pericyte", "Epithelial cell",                                    
                      "Myofibroblast", "Subtype 2 epithelial cell", "Myeloid cell",                               
                      "Mast cell" , "Natural killer cell", "cDC",                                        
                      "Tuft cell", "Stromal cell of lamina propria of colon", "Endothelial cell",                           
                      "Epithelial cell of large intestine", "Enterocyte of epithelium of large intestine", "Subtype 3 epithelial cell",                  
                      "Gamma-delta T cell", "CD8 T cell", "T follicular helper cell" 
)

names(cell_type_edited) <- levels(fov_integrated)
fov_integrated <- RenameIdents(fov_integrated, cell_type_edited)

# Adding object metadata with cluster names in order - to be used in the bar plots
fov_integrated$cell_type_edited <- factor(fov_integrated@active.ident)

ImageDimPlot(fov_integrated, fov = "Primary_fov01", group.by = "cell_type_edited", axes = TRUE, cols = cell_type_color, size = 1, boundaries = "segmentation")
ImageDimPlot(fov_integrated, fov = "Metastasis_fov22", group.by = "cell_type_edited", axes = TRUE, cols = "alphabet2", size = 1, boundaries = "segmentation")
#Options for cols are "alphabet", "alphabet2", "glasbey", "polychrome", "stepped", and "parade".

# UMAP of the identified clusters
DimPlot(fov_integrated, reduction = "umap", label = FALSE) #try other ploting packages and explore the function

dittoDimPlot(fov_integrated, var = "cell_type_edited",
             reduction.use = "umap", size = 2,
             do.label = TRUE, labels.size = 4, labels.highlight = TRUE) +
  theme(legend.title = element_blank()) +
  ggtitle("Cell identities on UMAP")

# Plot cell numbers and frequencies by sample
p <- dittoBarPlot(fov_integrated, var = "cell_type_edited", group.by = "sample_ID",  scale = c("percent")) 
p

# Manually define color code for each cluster label
cell_type_color <- setNames(c("#3F1B03", "#FFD966", "#894F36","#F4800C",
                              "#1C750C",  "#6471E2",  "#EF8ECC", "#4900EF", 
                              "#4DB23B",  "#066970", "#BF0A3D",
                              "#A87DFF", "#023FA5", "grey",  
                              "#66D9FF", "#b96cb8", "#f0b98d",
                              "#0fcfc0", "#c0cf0f", "#9cded6", "black"),
                            c("Endothelial cell", "Pericyte", "Myofibroblast", "Stromal cell of lamina propria of colon", 
                              "Epithelial cell", "Subtype 2 epithelial cell", "Tuft cell", "Goblet cell",
                              "Enterocyte of epithelium of large intestine", "Epithelial cell of large intestine", "Subtype 3 epithelial cell",
                              "cDC", "Plasma cell",  "Myeloid cell",
                              "CD8 T cell", "B cell", "Gamma-delta T cell",
                              "Mast cell", "Natural killer cell", "T cell", "T follicular helper cell"))

# Plot using the customised vector of colors above
ImageDimPlot(fov_integrated, fov = "Primary_fov01", group.by = "cell_type_edited", axes = TRUE, cols = cell_type_color, size = 1, boundaries = "segmentation")
ImageDimPlot(fov_integrated, fov = "Metastasis_fov22", group.by = "cell_type_edited", axes = TRUE, cols = cell_type_color, size = 1, boundaries = "segmentation")
# UMAP of the identified clusters
DimPlot(fov_integrated, reduction = "umap", label = FALSE, cols = cell_type_color, pt.size = 2)

# Plot specific cell types
# Vascular and stromal cells
p1 <- ImageDimPlot(fov_integrated, fov = "Primary_fov01", group.by = "cell_type_edited", axes = TRUE, cols = cell_type_color, size = 1, boundaries = "segmentation", cells = WhichCells(fov_integrated, idents = c("Endothelial cell", "Pericyte", "Myofibroblast", "Stromal cell of lamina propria of colon")))
p2 <- ImageDimPlot(fov_integrated, fov = "Metastasis_fov22", group.by = "cell_type_edited", axes = TRUE, cols = cell_type_color, size = 1, boundaries = "segmentation", cells = WhichCells(fov_integrated, idents = c("Endothelial cell", "Pericyte", "Myofibroblast", "Stromal cell of lamina propria of colon")))
p1 + p2
# Epithelial compartment
p3 <- ImageDimPlot(fov_integrated, fov = "Primary_fov01", group.by = "cell_type_edited", axes = TRUE, 
                   cols = cell_type_color, size = 1, boundaries = "segmentation", 
                   cells = WhichCells(fov_integrated, idents = c("Epithelial cell", "Subtype 2 epithelial cell", "Tuft cell", "Goblet cell",
                                                                 "Enterocyte of epithelium of large intestine", "Epithelial cell of large intestine", "Subtype 3 epithelial cell")))

p4 <- ImageDimPlot(fov_integrated, fov = "Metastasis_fov22", group.by = "cell_type_edited", axes = TRUE, 
                   cols = cell_type_color, size = 1, boundaries = "segmentation", 
                   cells = WhichCells(fov_integrated, idents = c("Epithelial cell", "Subtype 2 epithelial cell", "Tuft cell", "Goblet cell",
                                                                 "Enterocyte of epithelium of large intestine", "Epithelial cell of large intestine", "Subtype 3 epithelial cell")))
p3 + p4
# Immune compartment
p5 <- ImageDimPlot(fov_integrated, fov = "Primary_fov01", group.by = "cell_type_edited", axes = TRUE, 
                   cols = cell_type_color, size = 1, boundaries = "segmentation", 
                   cells = WhichCells(fov_integrated, idents = c("cDC", "Plasma cell",  "Myeloid cell",
                                                                 "CD8 T cell", "B cell", "Gamma-delta T cell",
                                                                 "Mast cell", "Natural killer cell", "T cell", "T follicular helper cell")))

p6 <- ImageDimPlot(fov_integrated, fov = "Metastasis_fov22", group.by = "cell_type_edited", axes = TRUE, 
                   cols = cell_type_color, size = 1, boundaries = "segmentation", 
                   cells = WhichCells(fov_integrated, idents = c("cDC", "Plasma cell",  "Myeloid cell",
                                                                 "CD8 T cell", "B cell", "Gamma-delta T cell",
                                                                 "Mast cell", "Natural killer cell", "T cell", "T follicular helper cell")))
p5 + p6

# Convertion of the SCE object to seurat loses the SCT slot.
# Test option below as aan alternative and avoid losing information when converting Seurat >> SCE >> Seurat object.
# Reference: https://keshav-motwani.github.io/scanalysis/articles/conversion.html
# Could not install in this version of R!
library(scanalysis)
sce_converted_new = fov_integrated %>%
  seurat_to_sce()

seurat_converted_new = sce_converted_new %>%
  sce_to_seurat()

# 9- Manual cell annotation of Seurat clusters based on the marker gene list of the reference dataset

Idents(fov_integrated) <- 'seurat_clusters'
levels(fov_integrated)

# 9.1- Rename idents of dsb clusters 
cluster_ID <- c("GNLY+ T cell", "ChemokineHighVEGFA+KRT15+ Epithelial cell", "Epithelial cell", "PIGR+ Epithelial cell", 
                "VEGFA+KRT15+ Epithelial cell", "Stromal cell", "Activated CD16+CD68+ Macrophage", "Tuft cell",
                "GNLY+ T cell", "SPP1+CCL2+ CD16+CD68+ Macrophage", "CXCL8+SOD2+ Neutrophil", "Plasma cell", "Plasma cell", "Plasma cell",
                "CXCL8+SOD2+ Neutrophil")

names(cluster_ID) <- levels(fov_integrated)
fov_integrated <- RenameIdents(fov_integrated, cluster_ID)

# 9.2- Adding object metadata with cluster names in order - to be used in the bar plots
fov_integrated$cluster_ID <- factor(fov_integrated@active.ident)

# 9.3- Visualisation of manually annotated clusters

ImageDimPlot(fov_integrated, fov = "fov01", group.by = "cluster_ID", axes = TRUE, cols = "polychrome", size = 1, boundaries = "segmentation")
ImageDimPlot(fov_integrated, fov = "fov22", group.by = "cluster_ID", axes = TRUE, cols = "polychrome", size = 1, boundaries = "segmentation")
#Options for cols are "alphabet", "alphabet2", "glasbey", "polychrome", "stepped", and "parade".

# UMAP of the identified clusters
DimPlot(fov_integrated, reduction = "umap", label = FALSE, cols = "polychrome", pt.size = 2) #try other ploting packages and explore the function

dittoDimPlot(fov_integrated, var = "cluster_ID",
             reduction.use = "umap", size = 2,
             do.label = TRUE, labels.size = 2, labels.highlight = TRUE) +
  theme(legend.title = element_blank()) +
  ggtitle("Manually annotated clusters on UMAP")

# Plot cell numbers and frequencies by sample
p <- dittoBarPlot(fov_integrated, var = "cluster_ID", group.by = "sample_ID",  scale = c("percent")) 
p
dittoBarPlot(fov_integrated, var = "cluster_ID", group.by = "sample_ID",  scale = c("count")) 

# Manually define color code for each cluster label
cluster_ID_color <- setNames(c( "#023FA5", "grey",  "#FF00FF", "#F71F0F", "#9933FF",
                                "#FFD966", "#66D9FF", "#006633",  "#00FF00",
                                "#FF8000", "#606060"),
                             c("Epithelial cell", "PIGR+ Epithelial cell", "VEGFA+KRT15+ Epithelial cell", "ChemokineHighVEGFA+KRT15+ Epithelial cell", "Tuft cell",
                               "Stromal cell", "CXCL8+SOD2+ Neutrophil", "Activated CD16+CD68+ Macrophage", "SPP1+CCL2+ CD16+CD68+ Macrophage", 
                               "Plasma cell", "GNLY+ T cell"))

# Plot using the customised vector of colors above
ImageDimPlot(fov_integrated, fov = "fov01", group.by = "cluster_ID", axes = TRUE, cols = cluster_ID_color, size = 1, boundaries = "segmentation")
ImageDimPlot(fov_integrated, fov = "fov22", group.by = "cluster_ID", axes = TRUE, cols = cluster_ID_color, size = 1, boundaries = "segmentation")
# UMAP of the identified clusters
DimPlot(fov_integrated, reduction = "umap", label = FALSE, cols = cluster_ID_color , pt.size = 2)

# Plot specific cell types
# Epithelial compartment
p1 <- ImageDimPlot(fov_integrated, fov = "Primary_fov01", group.by = "cluster_ID", axes = TRUE, cols = cluster_ID_color, size = 1, boundaries = "segmentation", cells = WhichCells(fov_integrated, idents = c("Epithelial cell", "PIGR+ Epithelial cell", "VEGFA+KRT15+ Epithelial cell", "ChemokineHighVEGFA+KRT15+ Epithelial cell", "Tuft cell")))
p2 <- ImageDimPlot(fov_integrated, fov = "Metastasis_fov22", group.by = "cluster_ID", axes = TRUE, cols = cluster_ID_color, size = 1, boundaries = "segmentation", cells = WhichCells(fov_integrated, idents = c("Epithelial cell", "PIGR+ Epithelial cell", "VEGFA+KRT15+ Epithelial cell", "ChemokineHighVEGFA+KRT15+ Epithelial cell", "Tuft cell")))
p1
p2

# Stromal compartment
p3 <- ImageDimPlot(fov_integrated, fov = "Primary_fov01", group.by = "cluster_ID", axes = TRUE, 
                   cols = cluster_ID_color, size = 1, boundaries = "segmentation", 
                   cells = WhichCells(fov_integrated, idents = c("Stromal cell")))

p4 <- ImageDimPlot(fov_integrated, fov = "Metastasis_fov22", group.by = "cluster_ID", axes = TRUE, 
                   cols = cluster_ID_color, size = 1, boundaries = "segmentation", 
                   cells = WhichCells(fov_integrated, idents = c("Stromal cell")))
p3
p4

# Immune compartment
p5 <- ImageDimPlot(fov_integrated, fov = "Primary_fov01", group.by = "cluster_ID", axes = TRUE, 
                   cols = cluster_ID_color, size = 1, boundaries = "segmentation", 
                   cells = WhichCells(fov_integrated, idents = c("CXCL8+SOD2+ Neutrophil", "Activated CD16+CD68+ Macrophage",
                                                                 "SPP1+CCL2+ CD16+CD68+ Macrophage", "Plasma cell", "GNLY+ T cell")))

p6 <- ImageDimPlot(fov_integrated, fov = "Metastasis_fov22", group.by = "cluster_ID", axes = TRUE, 
                   cols = cluster_ID_color, size = 1, boundaries = "segmentation", 
                   cells = WhichCells(fov_integrated, idents = c("CXCL8+SOD2+ Neutrophil", "Activated CD16+CD68+ Macrophage",
                                                                 "SPP1+CCL2+ CD16+CD68+ Macrophage", "Plasma cell", "GNLY+ T cell")))
p5
p6


# See error when loading data and images to create Seurat object...
p7 <- ImageDimPlot(fov_integrated, fov = "fov22", group.by = "cluster_ID", axes = TRUE, 
                   cols = cluster_ID_color, size = 1, boundaries = "segmentation", 
                   cells = WhichCells(fov_integrated, idents = c("Epithelial cell", "PIGR+ Epithelial cell", "VEGFA+KRT15+ Epithelial cell", "ChemokineHighVEGFA+KRT15+ Epithelial cell", "Tuft cell")), 
                   alpha = 0.3, molecules = c("PIGR", "CEACAM6"), mols.size = 0.01, mols.alpha = 1, nmols = 50000, border.color = "black", coord.fixed = FALSE)

p7

# 9- Assigning major cell types to cell identities

# Set idents from a value in object metadata - in this case the dsb clusters

colnames(BM_query[[]])
Idents(BM_query) <- 'predicted.celltype.l2'
levels(BM_query)

# Rename idents of dsb clusters 
major.cluster.ids <- c("B cell", "Hematopoietic Stem Cell", "DC", "CD4 T cell", "CD4 T cell", "Erythroid",
                       "CD8 T cell", "B cell",  "Myeloid", "HSPC", "CD8 T cell", "B cell",
                       "Erythroid", "HSPC", "B cell", "HSPC", "HSPC", "DC",
                       "DC", "HSPC", "CD4 T cell", "CD8 T cell", "Natural Killer", "DC",
                       "HSPC", "B cell", "DC", "DC", "Invariant T cell", "Myeloid",
                       "Myeloid", "Stromal cell", "B cell", "Innate Lymphocyte", "CD8 T cell", "CD8 T cell",
                       "Natural Killer", "Proliferating T cell", "Platelets", "Natural Killer")

names(major.cluster.ids) <- levels(BM_query)
BM_query <- RenameIdents(BM_query, major.cluster.ids)

# Adding object metadata with cluster names in order - to be used in the bar plots
BM_query$major_celltype.l2 <- factor(BM_query@active.ident)

# Visualise renamed/merged clusters
dittoDimPlot(BM_query, var = "major_celltype.l2",
             reduction.use = "proj.umap", size = 0.75,
             do.label = TRUE, labels.size = 4, labels.highlight = TRUE) +
  theme(legend.title = element_blank()) +
  ggtitle("Major cell types on UMAP")

# Frequency and total number of dsb clusters
dittoBarPlot(BM_query, var = "major_celltype.l2", group.by = "orig.ident", retain.factor.levels = TRUE)
dittoBarPlot(BM_query, var = "major_celltype.l2", group.by = "orig.ident", retain.factor.levels = TRUE, scale = "count")

################################################################################################################################################################################


